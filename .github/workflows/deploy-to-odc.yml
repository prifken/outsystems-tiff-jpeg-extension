name: Deploy to OutSystems ODC

# Trigger workflow on push to main branch or manual trigger
on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: false
        default: 'Development'
        type: string

# Define environment variables used across jobs
env:
  DOTNET_VERSION: '8.0.x'
  PROJECT_FILE: 'ImageConverterLibrary.csproj'
  ARTIFACT_NAME: 'ImageConverterLibrary'
  ZIP_FILE: 'ImageConverterLibrary.zip'

jobs:
  # ============================================================================
  # BUILD JOB - Compile and package the external logic library
  # ============================================================================
  build:
    name: Build External Logic Library
    runs-on: windows-latest

    steps:
      # Step 1: Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better context

      # Step 2: Setup .NET SDK
      - name: Setup .NET ${{ env.DOTNET_VERSION }}
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      # Step 3: Display .NET version for debugging
      - name: Display .NET version
        run: dotnet --version

      # Step 4: Inject Build Metadata and Code
      - name: Inject Build Metadata
        shell: pwsh
        run: |
          $buildId = "${{ github.run_number }}-${{ github.sha }}"
          $timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss UTC")
          $runNumber = "${{ github.run_number }}"

          Write-Host "Injecting build metadata:"
          Write-Host "  Build ID: $buildId"
          Write-Host "  Timestamp: $timestamp"
          Write-Host "  Run Number: $runNumber"

          # Create BuildInfo class with unique content
          $buildInfoPath = "BuildInfo.cs"
          @"
          using System;

          namespace ImageConverterLibrary
          {
              /// <summary>
              /// Auto-generated build information - DO NOT EDIT
              /// This class is regenerated on every build to force unique binary
              /// </summary>
              public static class BuildInfo
              {
                  public const string BuildId = "$buildId";
                  public const string BuildTimestamp = "$timestamp";
                  public const int BuildNumber = $runNumber;
                  public const string CommitSha = "${{ github.sha }}";

                  // Unique hash that changes every build
                  public const string BuildHash = "$buildId-$timestamp";
              }
          }
          "@ | Out-File -FilePath $buildInfoPath -Encoding UTF8

          Write-Host "âœ… BuildInfo.cs created with unique content"
          Write-Host "   This ensures ODC sees each build as different"

      # Step 5: Restore NuGet dependencies
      - name: Restore dependencies
        run: dotnet restore ${{ env.PROJECT_FILE }}

      # Step 6: Build the project in Release configuration with unique version
      - name: Build project
        shell: pwsh
        run: |
          Write-Host "Building with version 0.1.${{ github.run_number }}..."

          dotnet build ${{ env.PROJECT_FILE }} `
            --configuration Release `
            --no-restore `
            -p:Version=0.1.${{ github.run_number }} `
            -p:AssemblyVersion=0.1.${{ github.run_number }}.0 `
            -p:FileVersion=0.1.${{ github.run_number }}.0 `
            -p:Deterministic=false

          Write-Host "âœ… Build completed with unique version"

      # Step 7: Publish the project for linux-x64 runtime (ODC Lambda target)
      - name: Publish project
        shell: pwsh
        run: |
          Write-Host "Publishing library with version 0.1.${{ github.run_number }}..."

          dotnet publish ${{ env.PROJECT_FILE }} `
            --configuration Release `
            --runtime linux-x64 `
            --output ./publish `
            --no-build `
            -p:Version=0.1.${{ github.run_number }} `
            -p:AssemblyVersion=0.1.${{ github.run_number }}.0 `
            -p:FileVersion=0.1.${{ github.run_number }}.0 `
            -p:Deterministic=false

          Write-Host "âœ… Publish completed"
          Write-Host "Version: 0.1.${{ github.run_number }}"

      # Step 8: Create ZIP archive for ODC deployment
      - name: Create deployment package
        shell: pwsh
        run: |
          Write-Host "Creating ZIP archive from publish folder..."

          # Remove existing ZIP if present
          if (Test-Path ${{ env.ZIP_FILE }}) {
            Remove-Item ${{ env.ZIP_FILE }} -Force
            Write-Host "Removed existing ZIP file"
          }

          # Create new ZIP archive
          Compress-Archive -Path ./publish/* -DestinationPath ${{ env.ZIP_FILE }} -Force

          # Verify ZIP was created and show size
          if (Test-Path ${{ env.ZIP_FILE }}) {
            $zipSize = (Get-Item ${{ env.ZIP_FILE }}).Length / 1MB
            Write-Host "âœ… ZIP created successfully: ${{ env.ZIP_FILE }}"
            Write-Host "ğŸ“¦ Package size: $($zipSize.ToString('F2')) MB"
          } else {
            Write-Error "âŒ Failed to create ZIP file"
            exit 1
          }

      # Step 9: Upload ZIP artifact for deployment job
      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: ${{ env.ZIP_FILE }}
          retention-days: 30
          if-no-files-found: error

      # Step 10: Add build summary
      - name: Build summary
        shell: pwsh
        run: |
          Write-Output "## ğŸ‰ Build Successful" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "**Project:** ${{ env.PROJECT_FILE }}" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "**Configuration:** Release" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "**Runtime:** linux-x64" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "**Package:** ${{ env.ZIP_FILE }}" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "âœ… Ready for deployment to ODC" >> $env:GITHUB_STEP_SUMMARY

  # ============================================================================
  # DEPLOY JOB - Upload library to OutSystems ODC
  # ============================================================================
  deploy:
    name: Deploy to ODC Development
    runs-on: windows-latest
    needs: build
    environment: development

    steps:
      # Step 1: Download the build artifact
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}

      # Step 2: Verify artifact was downloaded
      - name: Verify artifact
        shell: pwsh
        run: |
          Write-Host "Verifying downloaded artifact..."

          if (Test-Path ${{ env.ZIP_FILE }}) {
            $zipSize = (Get-Item ${{ env.ZIP_FILE }}).Length / 1MB
            Write-Host "âœ… Artifact found: ${{ env.ZIP_FILE }}"
            Write-Host "ğŸ“¦ Size: $($zipSize.ToString('F2')) MB"
          } else {
            Write-Error "âŒ Artifact not found: ${{ env.ZIP_FILE }}"
            exit 1
          }

      # ========================================================================
      # STEP 1: AUTHENTICATION - DIAGNOSTIC MODE
      # ========================================================================
      - name: "Step 1: Authenticate with ODC"
        id: auth
        shell: pwsh
        run: |
          $stepStart = Get-Date
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "STEP 1: AUTHENTICATION - DIAGNOSTIC MODE"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          try {
              # === ENVIRONMENT DIAGNOSTICS ===
              Write-Host "`nğŸ“Š ENVIRONMENT INFORMATION:"
              Write-Host "Runner OS: $env:RUNNER_OS"
              Write-Host "Runner Name: $env:RUNNER_NAME"
              Write-Host "PowerShell Version: $($PSVersionTable.PSVersion)"
              Write-Host "GitHub Actions: $env:GITHUB_ACTIONS"
              Write-Host ""

              # === NETWORK DIAGNOSTICS ===
              Write-Host "ğŸŒ NETWORK DIAGNOSTICS:"
              $portalDomain = ([System.Uri]"${{ secrets.ODC_PORTAL_URL }}").Host
              Write-Host "Portal Domain: $portalDomain"

              # Test DNS resolution
              try {
                  Write-Host "`nDNS Resolution Test:"
                  $dnsResult = Resolve-DnsName -Name $portalDomain -ErrorAction Stop
                  Write-Host "âœ… DNS Resolution successful"
                  Write-Host "IP Addresses: $($dnsResult.IPAddress -join ', ')"
              } catch {
                  Write-Host "âŒ DNS Resolution failed: $($_.Exception.Message)" -ForegroundColor Red
              }

              # Test basic connectivity
              try {
                  Write-Host "`nConnectivity Test:"
                  $testConnection = Test-NetConnection -ComputerName $portalDomain -Port 443 -InformationLevel Detailed -ErrorAction Stop
                  Write-Host "âœ… TCP Connection successful"
                  Write-Host "Ping Succeeded: $($testConnection.PingSucceeded)"
                  Write-Host "TCP Test Succeeded: $($testConnection.TcpTestSucceeded)"
                  Write-Host "Remote Address: $($testConnection.RemoteAddress)"
              } catch {
                  Write-Host "âŒ Connectivity test failed: $($_.Exception.Message)" -ForegroundColor Yellow
              }

              # Test HTTPS connectivity
              try {
                  Write-Host "`nHTTPS Test (Root URL):"
                  $rootTest = Invoke-WebRequest -Uri "${{ secrets.ODC_PORTAL_URL }}/" -Method Head -TimeoutSec 10 -UseBasicParsing -ErrorAction Stop
                  Write-Host "âœ… HTTPS connection successful"
                  Write-Host "Status Code: $($rootTest.StatusCode)"
              } catch {
                  Write-Host "âš ï¸  HTTPS root test: $($_.Exception.Message)" -ForegroundColor Yellow
                  Write-Host "Status Code: $($_.Exception.Response.StatusCode.value__)"
              }

              Write-Host ""
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

              # === CREDENTIALS CHECK ===
              Write-Host "`nğŸ” CREDENTIALS VERIFICATION:"
              Write-Host "Portal URL: ${{ secrets.ODC_PORTAL_URL }}"
              Write-Host "Client ID: ${{ secrets.ODC_CLIENT_ID }}"
              Write-Host "Client ID Length: $("${{ secrets.ODC_CLIENT_ID }}".Length) characters"
              Write-Host "Client Secret Length: $("${{ secrets.ODC_CLIENT_SECRET }}".Length) characters"
              Write-Host ""

              # === URL CONSTRUCTION DIAGNOSTICS ===
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Host "ğŸ”— URL CONSTRUCTION DIAGNOSTICS:"
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

              $baseUrl = "${{ secrets.ODC_PORTAL_URL }}"
              Write-Host "`nBase URL Analysis:"
              Write-Host "Raw value length: $($baseUrl.Length) characters"
              Write-Host "Starts with 'https://': $($baseUrl.StartsWith('https://'))"
              Write-Host "Starts with 'http://': $($baseUrl.StartsWith('http://'))"
              Write-Host "Ends with '/': $($baseUrl.EndsWith('/'))"
              Write-Host "Contains whitespace: $($baseUrl -match '\s')"

              # Show first and last few characters (safe to expose)
              if ($baseUrl.Length -gt 10) {
                  $firstChars = $baseUrl.Substring(0, [Math]::Min(20, $baseUrl.Length))
                  $lastChars = $baseUrl.Substring([Math]::Max(0, $baseUrl.Length - 15))
                  Write-Host "First 20 chars: '$firstChars...'"
                  Write-Host "Last 15 chars: '...$lastChars'"
              } else {
                  Write-Host "Value too short - possible issue!"
              }

              # Test URL construction
              $discoveryUrl = "$baseUrl/identity/.well-known/openid-configuration"
              $tokenUrl = "$baseUrl/auth/realms/29ecfa4f-ec23-4ebe-8d8c-6d556d1daba4/protocol/openid-connect/token"

              Write-Host "`nConstructed URLs:"
              Write-Host "Discovery URL length: $($discoveryUrl.Length)"
              Write-Host "Token URL length: $($tokenUrl.Length)"

              # Check for double slashes (common error)
              $hasDoubleSlash = $discoveryUrl -match '//'
              if ($hasDoubleSlash) {
                  Write-Host "âš ï¸  WARNING: Discovery URL contains '//' - check for trailing slash in base URL!" -ForegroundColor Yellow
              }

              # Validate URL format
              try {
                  $uri = [System.Uri]$baseUrl
                  Write-Host "`nURL Parse Test:"
                  Write-Host "âœ… Base URL is valid URI"
                  Write-Host "Scheme: $($uri.Scheme)"
                  Write-Host "Host: $($uri.Host)"
                  Write-Host "Port: $($uri.Port)"
                  Write-Host "Path: '$($uri.PathAndQuery)'"
              } catch {
                  Write-Host "âŒ Base URL is NOT a valid URI: $($_.Exception.Message)" -ForegroundColor Red
              }

              Write-Host ""

              # === OIDC DISCOVERY ATTEMPT ===
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Host "PHASE 1A: OIDC DISCOVERY"
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

              $tokenEndpoint = $null
              $discoveryUrl = "${{ secrets.ODC_PORTAL_URL }}/identity/.well-known/openid-configuration"

              try {
                  Write-Host "`nğŸ” Attempting OIDC Discovery..."
                  Write-Host "URL: $discoveryUrl"
                  Write-Host "Method: GET"
                  Write-Host "Expected Response: JSON with token_endpoint"
                  Write-Host ""

                  $discoveryResponse = Invoke-WebRequest -Uri $discoveryUrl -Method Get -UseBasicParsing -ErrorAction Stop

                  Write-Host "âœ… OIDC Discovery HTTP request succeeded!" -ForegroundColor Green
                  Write-Host "Status Code: $($discoveryResponse.StatusCode)"
                  Write-Host "Content Type: $($discoveryResponse.Headers.'Content-Type')"
                  Write-Host "Content Length: $($discoveryResponse.Content.Length) bytes"
                  Write-Host ""

                  $discovery = $discoveryResponse.Content | ConvertFrom-Json
                  $tokenEndpoint = $discovery.token_endpoint

                  Write-Host "âœ… OIDC Discovery parsed successfully!" -ForegroundColor Green
                  Write-Host "Issuer: $($discovery.issuer)"
                  Write-Host "Token Endpoint: $tokenEndpoint"
                  Write-Host "Supported Grants: $($discovery.grant_types_supported -join ', ')"

              } catch {
                  Write-Host "âŒ OIDC Discovery FAILED!" -ForegroundColor Red
                  Write-Host "Error Type: $($_.Exception.GetType().FullName)"
                  Write-Host "Error Message: $($_.Exception.Message)"

                  if ($_.Exception.Response) {
                      Write-Host "HTTP Status Code: $($_.Exception.Response.StatusCode.value__) - $($_.Exception.Response.StatusDescription)"
                      Write-Host "Response URL: $($_.Exception.Response.ResponseUri)"

                      try {
                          $reader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
                          $errorBody = $reader.ReadToEnd()
                          Write-Host "`nError Response Body:"
                          Write-Host $errorBody
                      } catch {
                          Write-Host "Could not read error response body"
                      }
                  }

                  Write-Host "`nâš ï¸  Falling back to hardcoded endpoint..." -ForegroundColor Yellow
                  $tokenEndpoint = "${{ secrets.ODC_PORTAL_URL }}/auth/realms/29ecfa4f-ec23-4ebe-8d8c-6d556d1daba4/protocol/openid-connect/token"
                  Write-Host "Fallback Token Endpoint: $tokenEndpoint"
              }

              if ([string]::IsNullOrEmpty($tokenEndpoint)) {
                  throw "FATAL: Could not determine token endpoint from discovery or fallback"
              }

              # === TOKEN REQUEST ATTEMPT ===
              Write-Host ""
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Host "PHASE 1B: TOKEN REQUEST"
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

              Write-Host "`nğŸ” Requesting OAuth2 Access Token..."
              Write-Host "Endpoint: $tokenEndpoint"
              Write-Host "Method: POST"
              Write-Host "Content-Type: application/x-www-form-urlencoded"
              Write-Host "Grant Type: client_credentials"
              Write-Host "Client ID: ${{ secrets.ODC_CLIENT_ID }}"
              Write-Host ""

              $body = @{
                  grant_type    = "client_credentials"
                  client_id     = "${{ secrets.ODC_CLIENT_ID }}"
                  client_secret = "${{ secrets.ODC_CLIENT_SECRET }}"
              }

              try {
                  $tokenResponse = Invoke-WebRequest -Uri $tokenEndpoint -Method Post -Body $body -ContentType "application/x-www-form-urlencoded" -UseBasicParsing -ErrorAction Stop

                  Write-Host "âœ… Token request HTTP succeeded!" -ForegroundColor Green
                  Write-Host "Status Code: $($tokenResponse.StatusCode)"
                  Write-Host "Content Type: $($tokenResponse.Headers.'Content-Type')"
                  Write-Host ""

                  $response = $tokenResponse.Content | ConvertFrom-Json
                  $accessToken = $response.access_token

                  if ([string]::IsNullOrEmpty($accessToken)) {
                      throw "FATAL: Access token is empty in response"
                  }

                  Write-Host "âœ… ACCESS TOKEN OBTAINED!" -ForegroundColor Green
                  Write-Host "Token Type: $($response.token_type)"
                  Write-Host "Token Length: $($accessToken.Length) characters"
                  Write-Host "Expires In: $($response.expires_in) seconds ($([Math]::Round($response.expires_in / 3600, 1)) hours)"

                  # Save and mask token
                  "ACCESS_TOKEN=$accessToken" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
                  Write-Host "::add-mask::$accessToken"

                  $stepDuration = (Get-Date) - $stepStart
                  Write-Host ""
                  Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                  Write-Host "âœ… STEP 1 COMPLETE - AUTHENTICATION SUCCESSFUL"
                  Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                  Write-Host "â±ï¸  Total time: $($stepDuration.TotalSeconds.ToString('F2'))s"
                  Write-Host ""

              } catch {
                  Write-Host "âŒ TOKEN REQUEST FAILED!" -ForegroundColor Red
                  Write-Host "Error Type: $($_.Exception.GetType().FullName)"
                  Write-Host "Error Message: $($_.Exception.Message)"

                  if ($_.Exception.Response) {
                      Write-Host "`nHTTP Response Details:"
                      Write-Host "Status Code: $($_.Exception.Response.StatusCode.value__) - $($_.Exception.Response.StatusDescription)"
                      Write-Host "Response URL: $($_.Exception.Response.ResponseUri)"

                      try {
                          $reader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
                          $errorBody = $reader.ReadToEnd()
                          Write-Host "`nError Response Body:"
                          Write-Host $errorBody

                          # Try to parse as JSON
                          try {
                              $errorJson = $errorBody | ConvertFrom-Json
                              if ($errorJson.error) {
                                  Write-Host "`nParsed OAuth Error:"
                                  Write-Host "Error: $($errorJson.error)"
                                  Write-Host "Description: $($errorJson.error_description)"
                              }
                          } catch {
                              # Not JSON, already displayed above
                          }
                      } catch {
                          Write-Host "Could not read error response body"
                      }
                  }

                  throw "Token request failed - see details above"
              }

          } catch {
              Write-Host ""
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Host "âŒ STEP 1 FAILED - AUTHENTICATION ERROR"
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Host "Error: $($_.Exception.Message)"
              Write-Host ""
              Write-Host "ğŸ” TROUBLESHOOTING CHECKLIST:"
              Write-Host "1. âœ“ Check DNS resolution above"
              Write-Host "2. âœ“ Check TCP connectivity above"
              Write-Host "3. âœ“ Check OIDC Discovery result above"
              Write-Host "4. âœ“ Check token request result above"
              Write-Host "5. Verify ODC_PORTAL_URL in GitHub Secrets"
              Write-Host "6. Verify ODC_CLIENT_ID and ODC_CLIENT_SECRET"
              Write-Host "7. Check API client permissions in ODC Portal"
              Write-Host "8. Consider using self-hosted runner if network blocked"
              Write-Host ""
              exit 1
          }

      # ========================================================================
      # STEP 2: Get Pre-signed Upload URL (Official API Step 1)
      # ========================================================================
      - name: "Step 2: Get Upload URL (Official API)"
        id: upload_url
        shell: pwsh
        env:
          ACCESS_TOKEN: ${{ steps.auth.outputs.ACCESS_TOKEN }}
        run: |
          $stepStart = Get-Date
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "STEP 2: GET UPLOAD URL (OFFICIAL API STEP 1)"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          Write-Host "`nğŸ“¥ INPUTS:"
          Write-Host "  ACCESS_TOKEN: $(if($env:ACCESS_TOKEN) {'***SET***'} else {'NOT SET'})"
          Write-Host ""

          try {
            # Official API Step 1: GET /api/external-libraries/v1/uploads
            $apiUrl = "${{ secrets.ODC_PORTAL_URL }}/api/external-libraries/v1/uploads"

            $headers = @{
              "Authorization" = "Bearer $env:ACCESS_TOKEN"
            }

            Write-Host "ğŸ“¡ REQUEST:"
            Write-Host "  Method: GET"
            Write-Host "  URL: $apiUrl"
            Write-Host "  Headers: Authorization: Bearer ***"
            Write-Host ""

            Write-Host "ğŸ”„ Requesting pre-signed upload URLs..."
            $response = Invoke-RestMethod -Uri $apiUrl -Method Get -Headers $headers

            Write-Host "`nğŸ“‹ RESPONSE:"
            Write-Host ($response | ConvertTo-Json -Depth 3)
            Write-Host ""

            $uploadUrl = $response.uploadUrl
            $downloadUrl = $response.downloadUrl

            Write-Host "ğŸ“¤ EXTRACTED VALUES:"
            Write-Host "  uploadUrl: $(if($uploadUrl) {'***SET***'} else {'MISSING'})"
            Write-Host "  downloadUrl: $(if($downloadUrl) {'***SET***'} else {'MISSING'})"
            Write-Host ""

            if ([string]::IsNullOrEmpty($uploadUrl) -or [string]::IsNullOrEmpty($downloadUrl)) {
              throw "Missing uploadUrl or downloadUrl in response"
            }

            # Save URLs to outputs
            "UPLOAD_URL=$uploadUrl" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "DOWNLOAD_URL=$downloadUrl" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

            # Mask S3 URLs in logs
            Write-Host "::add-mask::$uploadUrl"
            Write-Host "::add-mask::$downloadUrl"

            $stepDuration = (Get-Date) - $stepStart
            Write-Host "âœ… Pre-signed URLs obtained"
            Write-Host "â±ï¸  Step 2 completed in $($stepDuration.TotalSeconds.ToString('F2'))s"
            Write-Host ""

          } catch {
            Write-Host ""
            Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            Write-Host "âŒ STEP 2 FAILED"
            Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            Write-Error "Error: $($_.Exception.Message)"

            if ($_.Exception.Response) {
              Write-Host "HTTP Status: $($_.Exception.Response.StatusCode.value__)"
              try {
                $reader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
                $errorBody = $reader.ReadToEnd()
                Write-Host "Response: $errorBody"
              } catch {}
            }

            Write-Host ""
            Write-Host "ğŸ” TROUBLESHOOTING:"
            Write-Host "1. Verify API client has 'Asset management > Create' permission"
            Write-Host "2. Check ACCESS_TOKEN is valid and not expired"
            Write-Host "3. Verify ODC_PORTAL_URL is correct"
            Write-Host ""
            exit 1
          }

      # ========================================================================
      # STEP 3: Upload ZIP to S3
      # ========================================================================
      - name: "Step 3: Upload ZIP to S3 (Official API Step 2)"
        shell: pwsh
        env:
          UPLOAD_URL: ${{ steps.upload_url.outputs.UPLOAD_URL }}
        run: |
          $stepStart = Get-Date
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "STEP 3: UPLOAD ZIP TO S3 (OFFICIAL API STEP 2)"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          Write-Host "`nğŸ“¥ INPUTS:"
          Write-Host "  UPLOAD_URL: $(if($env:UPLOAD_URL) {'***SET***'} else {'NOT SET'})"
          Write-Host "  ZIP_FILE: ${{ env.ZIP_FILE }}"
          Write-Host ""

          try {
            $zipPath = Resolve-Path ${{ env.ZIP_FILE }}
            $zipBytes = [System.IO.File]::ReadAllBytes($zipPath)
            $zipSizeMB = $zipBytes.Length / 1MB

            Write-Host "ğŸ“¡ REQUEST:"
            Write-Host "  Method: PUT"
            Write-Host "  URL: ***uploadUrl***"
            Write-Host "  Content-Type: application/zip"
            Write-Host "  Body Size: $($zipSizeMB.ToString('F2')) MB"
            Write-Host ""
            Write-Host "ğŸš€ Uploading to S3..."

            $headers = @{
              "Content-Type" = "application/zip"
            }

            Invoke-RestMethod -Uri $env:UPLOAD_URL -Method Put -Headers $headers -Body $zipBytes | Out-Null

            $stepDuration = (Get-Date) - $stepStart
            Write-Host "âœ… ZIP uploaded successfully"
            Write-Host "â±ï¸  Step 3 completed in $($stepDuration.TotalSeconds.ToString('F2'))s"
            Write-Host ""

          } catch {
            Write-Error "âŒ Step 3 failed: $($_.Exception.Message)"
            exit 1
          }

      # ========================================================================
      # STEP 4: Start Generation Operation (Official API Step 3)
      # ========================================================================
      - name: "Step 4: Start Generation Operation (Official API)"
        id: start_generation
        shell: pwsh
        env:
          ACCESS_TOKEN: ${{ steps.auth.outputs.ACCESS_TOKEN }}
          DOWNLOAD_URL: ${{ steps.upload_url.outputs.DOWNLOAD_URL }}
        run: |
          $stepStart = Get-Date
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "STEP 4: START GENERATION OPERATION (OFFICIAL API STEP 3)"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          Write-Host "`nğŸ“¥ INPUTS:"
          Write-Host "  ACCESS_TOKEN: $(if($env:ACCESS_TOKEN) {'***SET***'} else {'NOT SET'})"
          Write-Host "  DOWNLOAD_URL: $(if($env:DOWNLOAD_URL) {'***SET***'} else {'NOT SET'})"
          Write-Host "  ZIP_FILE: ${{ env.ZIP_FILE }}"
          Write-Host ""

          try {
            # Official API Step 3: POST /api/external-libraries/v1/generation-operations/
            $apiUrl = "${{ secrets.ODC_PORTAL_URL }}/api/external-libraries/v1/generation-operations/"

            $headers = @{
              "Authorization" = "Bearer $env:ACCESS_TOKEN"
              "Content-Type" = "application/json"
            }

            # Per official docs: body needs fileName and highCodeBinaryUri
            $body = @{
              fileName = "${{ env.ZIP_FILE }}"
              highCodeBinaryUri = $env:DOWNLOAD_URL
            } | ConvertTo-Json

            Write-Host "ğŸ“¡ REQUEST:"
            Write-Host "  Method: POST"
            Write-Host "  URL: $apiUrl"
            Write-Host "  Headers: Authorization: Bearer ***"
            Write-Host "  Headers: Content-Type: application/json"
            Write-Host "  Body:"
            Write-Host $body
            Write-Host ""

            Write-Host "ğŸ”„ Starting library generation operation..."
            $response = Invoke-RestMethod -Uri $apiUrl -Method Post -Headers $headers -Body $body

            Write-Host "`nğŸ“‹ RESPONSE:"
            Write-Host ($response | ConvertTo-Json -Depth 5)
            Write-Host ""

            $operationKey = $response.operationKey

            if ([string]::IsNullOrEmpty($operationKey)) {
              throw "No operationKey in response - cannot poll for completion"
            }

            Write-Host "ğŸ“¤ OPERATION KEY: $operationKey"
            Write-Host ""

            # Save operation key for next step
            "OPERATION_KEY=$operationKey" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

            $stepDuration = (Get-Date) - $stepStart
            Write-Host "âœ… Generation operation started"
            Write-Host "â±ï¸  Step 4 completed in $($stepDuration.TotalSeconds.ToString('F2'))s"
            Write-Host ""

          } catch {
            Write-Host ""
            Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            Write-Host "âŒ STEP 4 FAILED"
            Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            Write-Error "Error: $($_.Exception.Message)"

            if ($_.Exception.Response) {
              Write-Host "HTTP Status: $($_.Exception.Response.StatusCode.value__)"
              try {
                $reader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
                $errorBody = $reader.ReadToEnd()
                Write-Host "Response: $errorBody"
              } catch {}
            }

            Write-Host ""
            Write-Host "ğŸ” TROUBLESHOOTING:"
            Write-Host "1. Verify API client has 'Asset management > Create' permission"
            Write-Host "2. Check that ZIP file name and downloadURL are correct"
            Write-Host "3. Verify ACCESS_TOKEN is valid"
            Write-Host ""
            exit 1
          }

      # ========================================================================
      # STEP 5: Poll Generation Operation (Official API Step 4)
      # ========================================================================
      - name: "Step 5: Poll Generation Operation Status"
        id: poll_operation
        shell: pwsh
        env:
          ACCESS_TOKEN: ${{ steps.auth.outputs.ACCESS_TOKEN }}
          OPERATION_KEY: ${{ steps.start_generation.outputs.OPERATION_KEY }}
        run: |
          $stepStart = Get-Date
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "STEP 5: POLL GENERATION OPERATION STATUS (OFFICIAL API STEP 4)"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          Write-Host "`nğŸ“¥ INPUTS:"
          Write-Host "  ACCESS_TOKEN: $(if($env:ACCESS_TOKEN) {'***SET***'} else {'NOT SET'})"
          Write-Host "  OPERATION_KEY: $env:OPERATION_KEY"
          Write-Host ""

          try {
            $headers = @{
              "Authorization" = "Bearer $env:ACCESS_TOKEN"
            }

            # Official API Step 4: GET /api/external-libraries/v1/generation-operations/{operationKey}
            $apiUrl = "${{ secrets.ODC_PORTAL_URL }}/api/external-libraries/v1/generation-operations/$env:OPERATION_KEY"

            Write-Host "ğŸ“¡ Polling generation operation status..."
            Write-Host "URL: $apiUrl"
            Write-Host ""

            $maxAttempts = 60  # 5 minutes max (5 second intervals)
            $attempt = 0
            $status = $null
            $libraryKey = $null

            while ($attempt -lt $maxAttempts) {
              $attempt++
              Write-Host "Polling attempt $attempt/$maxAttempts..."

              $response = Invoke-RestMethod -Uri $apiUrl -Method Get -Headers $headers

              $status = $response.status
              $libraryKey = $response.libraryKey

              Write-Host "Status: $status"

              if ($status -eq "Completed") {
                Write-Host "`nâœ… Generation completed successfully!"
                Write-Host ""
                Write-Host "ğŸ“‹ FINAL RESPONSE:"
                Write-Host ($response | ConvertTo-Json -Depth 5)
                Write-Host ""
                break
              } elseif ($status -eq "ReadyForReview") {
                Write-Host "`nâš ï¸  Library is ready for review!"
                Write-Host ""
                Write-Host "ğŸ“‹ RESPONSE:"
                Write-Host ($response | ConvertTo-Json -Depth 5)
                Write-Host ""
                Write-Host "The library has been generated but is in 'ReadyForReview' status."
                Write-Host "This may require manual approval in the ODC Portal."
                Write-Host ""

                if ([string]::IsNullOrEmpty($libraryKey)) {
                  Write-Host "âš ï¸  No libraryKey in response - library may need approval first"
                  Write-Host ""
                  Write-Host "ACTION REQUIRED:"
                  Write-Host "1. Go to ODC Portal â†’ Libraries"
                  Write-Host "2. Find and review the library"
                  Write-Host "3. Approve it manually"
                  Write-Host ""
                  throw "Library is ReadyForReview but has no libraryKey - manual approval may be required"
                } else {
                  Write-Host "âœ… libraryKey found in ReadyForReview response: $libraryKey"
                  Write-Host "Proceeding with deployment..."
                  Write-Host ""
                  break
                }
              } elseif ($status -eq "Failed") {
                Write-Host "`nâŒ Generation failed!"
                Write-Host "Response:"
                Write-Host ($response | ConvertTo-Json -Depth 5)
                throw "Library generation failed - check ODC portal for details"
              } elseif ($status -eq "Processing" -or $status -eq "Pending" -or $status -eq "Generating") {
                Write-Host "Still $($status.ToLower())... waiting 5 seconds"
                Start-Sleep -Seconds 5
              } else {
                Write-Host "âš ï¸  Unknown status: $status"
                Write-Host "Full response:"
                Write-Host ($response | ConvertTo-Json -Depth 5)
                Write-Host ""
                Write-Host "Waiting 5 seconds to see if status changes..."
                Start-Sleep -Seconds 5
              }
            }

            if ($status -ne "Completed" -and $status -ne "ReadyForReview") {
              throw "Generation did not complete within timeout period (5 minutes). Final status: $status"
            }

            if ([string]::IsNullOrEmpty($libraryKey)) {
              throw "No libraryKey in completed response"
            }

            Write-Host "ğŸ“¤ LIBRARY KEY: $libraryKey"

            # Save library key for next step
            "LIBRARY_KEY=$libraryKey" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

            $stepDuration = (Get-Date) - $stepStart
            Write-Host ""
            Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            Write-Host "âœ… STEP 5 COMPLETE"
            Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            Write-Host "Library Key: $libraryKey"
            Write-Host "â±ï¸  Total time: $($stepDuration.TotalSeconds.ToString('F2'))s"
            Write-Host ""

          } catch {
            Write-Host ""
            Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            Write-Host "âŒ STEP 5 FAILED"
            Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            Write-Error "Error: $($_.Exception.Message)"

            if ($_.Exception.Response) {
              Write-Host "HTTP Status: $($_.Exception.Response.StatusCode.value__)"
              try {
                $reader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
                $errorBody = $reader.ReadToEnd()
                Write-Host "Response: $errorBody"
              } catch {}
            }

            Write-Host ""
            exit 1
          }

      # ========================================================================
      # STEP 6: Tag Library Revision
      # ========================================================================
      - name: "Step 6: Tag Library Revision"
        id: tag_revision
        shell: pwsh
        env:
          ACCESS_TOKEN: ${{ steps.auth.outputs.ACCESS_TOKEN }}
          LIBRARY_KEY: ${{ steps.poll_operation.outputs.LIBRARY_KEY }}
        run: |
          $stepStart = Get-Date
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "STEP 6: TAG LIBRARY REVISION"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          Write-Host "`nğŸ“¥ INPUTS:"
          Write-Host "  ACCESS_TOKEN: $(if($env:ACCESS_TOKEN) {'***SET***'} else {'NOT SET'})"
          Write-Host "  LIBRARY_KEY: $env:LIBRARY_KEY"
          Write-Host ""

          try {
              $headers = @{
                  "Authorization" = "Bearer $env:ACCESS_TOKEN"
                  "Content-Type" = "application/json"
              }

              # Query revisions to find the latest one (just created)
              $revisionsUrl = "${{ secrets.ODC_PORTAL_URL }}/api/asset-repository/v1/assets/$env:LIBRARY_KEY/revisions"
              Write-Host "ğŸ“¡ GET $revisionsUrl"
              Write-Host ""

              $response = Invoke-RestMethod -Uri $revisionsUrl -Method Get -Headers $headers
              $revisions = $response.results

              Write-Host "Found $($revisions.Count) total revision(s)"
              Write-Host ""

              # Debug: Show first revision structure
              if ($revisions.Count -gt 0) {
                Write-Host "ğŸ“‹ FIRST REVISION STRUCTURE:"
                Write-Host ($revisions[0] | ConvertTo-Json -Depth 3)
                Write-Host ""
                Write-Host "Available properties: $($revisions[0].PSObject.Properties.Name -join ', ')"
                Write-Host ""
              }

              # Get the latest revision (highest revision number)
              # Try different possible property names
              $latestRevision = $revisions | Sort-Object -Property @{Expression={
                if ($_.revisionNumber) { $_.revisionNumber }
                elseif ($_.RevisionNumber) { $_.RevisionNumber }
                elseif ($_.revision) { $_.revision }
                elseif ($_.number) { $_.number }
                else { 0 }
              }} -Descending | Select-Object -First 1

              # Extract revision number trying different property names
              $revisionNumber = if ($latestRevision.revisionNumber) { $latestRevision.revisionNumber }
                               elseif ($latestRevision.RevisionNumber) { $latestRevision.RevisionNumber }
                               elseif ($latestRevision.revision) { $latestRevision.revision }
                               elseif ($latestRevision.number) { $latestRevision.number }
                               else { $null }

              Write-Host "Latest revision number: $revisionNumber"
              Write-Host "Current tag: $(if($latestRevision.tag) {$latestRevision.tag} else {'<none>'})"
              Write-Host ""

              if ([string]::IsNullOrEmpty($revisionNumber) -or $revisionNumber -eq 0) {
                Write-Host "âŒ Could not determine revision number!"
                Write-Host "Latest revision object:"
                Write-Host ($latestRevision | ConvertTo-Json -Depth 3)
                throw "Unable to extract revision number from API response"
              }

              # Calculate next version number based on ALL existing tags
              $allTags = $revisions | Where-Object { $_.tag } | Select-Object -ExpandProperty tag | Sort-Object -Descending

              if ($allTags.Count -gt 0) {
                  $latestTag = $allTags[0]
                  Write-Host "Previous latest version: $latestTag"

                  # Auto-increment patch version
                  if ($latestTag -match '^(\d+)\.(\d+)\.(\d+)') {
                      $major = [int]$matches[1]
                      $minor = [int]$matches[2]
                      $patch = [int]$matches[3] + 1
                      $newTag = "$major.$minor.$patch"
                  } else {
                      $newTag = "0.1.${{ github.run_number }}"
                  }
              } else {
                  $newTag = "0.1.0"
              }

              Write-Host "New version tag: $newTag"
              Write-Host ""

              # Tag the latest revision
              $tagUrl = "${{ secrets.ODC_PORTAL_URL }}/api/asset-repository/v1/assets/$env:LIBRARY_KEY/revisions/$revisionNumber"
              Write-Host "ğŸ“¡ PATCH $tagUrl"

              $body = @{
                  tag = $newTag
                  releaseNotes = "Automated deployment from GitHub Actions`n`nRun: #${{ github.run_number }}`nCommit: ${{ github.sha }}`nBranch: ${{ github.ref_name }}`n`nTriggered by: ${{ github.event_name }}"
                  commitMessage = "Release $newTag via GitHub Actions"
              } | ConvertTo-Json

              Write-Host "Body:"
              Write-Host $body
              Write-Host ""

              $tagResponse = Invoke-RestMethod -Uri $tagUrl -Method Patch -Headers $headers -Body $body

              Write-Host "âœ… Successfully tagged revision $revisionNumber as $newTag!"
              Write-Host ""
              Write-Host "Response:"
              Write-Host ($tagResponse | ConvertTo-Json -Depth 3)
              Write-Host ""

              # Save for summary
              "REVISION_NUMBER=$revisionNumber" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
              "VERSION_TAG=$newTag" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

              $stepDuration = (Get-Date) - $stepStart
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Host "âœ… STEP 6 COMPLETE"
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Host "â±ï¸  Total time: $($stepDuration.TotalSeconds.ToString('F2'))s"
              Write-Host ""

          } catch {
              Write-Host ""
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Host "âŒ STEP 6 FAILED"
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Error "Error: $($_.Exception.Message)"

              if ($_.Exception.Response) {
                  Write-Host "HTTP Status: $($_.Exception.Response.StatusCode.value__)"
                  try {
                      $reader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
                      Write-Host "Response: $($reader.ReadToEnd())"
                  } catch {}
              }

              Write-Host ""
              exit 1
          }

      # ========================================================================
      # STEP 7: Deployment Complete
      # ========================================================================
      - name: "Step 7: Deployment Complete"
        id: deploy
        shell: pwsh
        env:
          VERSION_TAG: ${{ steps.tag_revision.outputs.VERSION_TAG }}
          LIBRARY_NAME: ImageConverter
        run: |
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "ğŸ‰ DEPLOYMENT COMPLETE!"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host ""
          Write-Host "Library has been successfully:"
          Write-Host "âœ… Uploaded to ODC"
          Write-Host "âœ… Generated and processed"
          Write-Host "âœ… Tagged as release version $env:VERSION_TAG"
          Write-Host ""
          Write-Host "The library is now available in ODC Portal for:"
          Write-Host "- Manual deployment to stages"
          Write-Host "- Integration into applications"
          Write-Host "- Further configuration"
          Write-Host ""
          Write-Host "Next steps in ODC Portal:"
          Write-Host "1. Navigate to Libraries section"
          Write-Host "2. Find your library: $env:LIBRARY_NAME"
          Write-Host "3. Deploy the tagged revision to desired stage"
          Write-Host ""

      # ========================================================================
      # SUCCESS SUMMARY
      # ========================================================================
      - name: Deployment Summary
        if: success()
        shell: pwsh
        env:
          LIBRARY_NAME: ImageConverter
          LIBRARY_KEY: ${{ steps.poll_operation.outputs.LIBRARY_KEY }}
          REVISION_NUMBER: ${{ steps.tag_revision.outputs.REVISION_NUMBER }}
          VERSION_TAG: ${{ steps.tag_revision.outputs.VERSION_TAG }}
        run: |
          Write-Output "## ğŸ‰ Deployment Successful" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "### Library Information" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Name:** $env:LIBRARY_NAME" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Library Key:** ``$env:LIBRARY_KEY``" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Revision:** $env:REVISION_NUMBER" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Version Tag:** $env:VERSION_TAG" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "### Deployment Details" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Environment:** Development" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Portal:** ${{ secrets.ODC_PORTAL_URL }}" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Deployed:** $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Run:** #${{ github.run_number }}" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "âœ… All 7 deployment steps completed successfully!" >> $env:GITHUB_STEP_SUMMARY

      # ========================================================================
      # FAILURE SUMMARY
      # ========================================================================
      - name: Deployment Failure Summary
        if: failure()
        shell: pwsh
        run: |
          Write-Output "## âŒ Deployment Failed" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "The deployment to ODC Development environment failed." >> $env:GITHUB_STEP_SUMMARY
          Write-Output "Please check the logs above for detailed error information." >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "### Common Issues" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 1:** Invalid credentials or OIDC Discovery failure" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 2:** API permissions or endpoint not available" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 3:** S3 upload failure or network issues" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 4:** Invalid ZIP package or generation request" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 5:** Generation timeout or compilation errors" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 6:** Release creation failure" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 7:** Deployment to stage failure" >> $env:GITHUB_STEP_SUMMARY
