name: Deploy to OutSystems ODC

# Trigger workflow on push to main branch or manual trigger
on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: false
        default: 'Development'
        type: string

# Define environment variables used across jobs
env:
  DOTNET_VERSION: '8.0.x'
  PROJECT_FILE: 'ImageConverterLibrary.csproj'
  ARTIFACT_NAME: 'ImageConverterLibrary'
  ZIP_FILE: 'ImageConverterLibrary.zip'

jobs:
  # ============================================================================
  # BUILD JOB - Compile and package the external logic library
  # ============================================================================
  build:
    name: Build External Logic Library
    runs-on: windows-latest

    steps:
      # Step 1: Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better context

      # Step 2: Setup .NET SDK
      - name: Setup .NET ${{ env.DOTNET_VERSION }}
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      # Step 3: Display .NET version for debugging
      - name: Display .NET version
        run: dotnet --version

      # Step 4: Inject Build Metadata
      - name: Inject Build Metadata
        shell: pwsh
        run: |
          $buildId = "${{ github.run_number }}-${{ github.sha }}"
          $timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss UTC")

          Write-Host "Injecting build metadata:"
          Write-Host "  Build ID: $buildId"
          Write-Host "  Timestamp: $timestamp"

          # Update AssemblyInfo or add build constant
          $assemblyInfoPath = "Properties/AssemblyInfo.cs"

          if (Test-Path $assemblyInfoPath) {
            # Add to existing AssemblyInfo
            Add-Content $assemblyInfoPath "`n[assembly: AssemblyMetadata(`"BuildId`", `"$buildId`")]"
            Add-Content $assemblyInfoPath "[assembly: AssemblyMetadata(`"BuildTimestamp`", `"$timestamp`")]"
          } else {
            # Create AssemblyInfo.cs
            New-Item -ItemType Directory -Force -Path "Properties" | Out-Null
            @"
          using System.Reflection;

          [assembly: AssemblyMetadata("BuildId", "$buildId")]
          [assembly: AssemblyMetadata("BuildTimestamp", "$timestamp")]
          "@ | Out-File -FilePath $assemblyInfoPath -Encoding UTF8
          }

          Write-Host "âœ… Build metadata injected"

      # Step 5: Restore NuGet dependencies
      - name: Restore dependencies
        run: dotnet restore ${{ env.PROJECT_FILE }}

      # Step 6: Build the project in Release configuration with unique version
      - name: Build project
        shell: pwsh
        run: |
          Write-Host "Building with version 0.1.${{ github.run_number }}..."

          dotnet build ${{ env.PROJECT_FILE }} `
            --configuration Release `
            --no-restore `
            -p:Version=0.1.${{ github.run_number }} `
            -p:AssemblyVersion=0.1.${{ github.run_number }}.0 `
            -p:FileVersion=0.1.${{ github.run_number }}.0 `
            -p:Deterministic=false

          Write-Host "âœ… Build completed with unique version"

      # Step 7: Publish the project for linux-x64 runtime (ODC Lambda target)
      - name: Publish project
        shell: pwsh
        run: |
          Write-Host "Publishing library with version 0.1.${{ github.run_number }}..."

          dotnet publish ${{ env.PROJECT_FILE }} `
            --configuration Release `
            --runtime linux-x64 `
            --output ./publish `
            --no-build `
            -p:Version=0.1.${{ github.run_number }} `
            -p:AssemblyVersion=0.1.${{ github.run_number }}.0 `
            -p:FileVersion=0.1.${{ github.run_number }}.0 `
            -p:Deterministic=false

          Write-Host "âœ… Publish completed"
          Write-Host "Version: 0.1.${{ github.run_number }}"

      # Step 8: Create ZIP archive for ODC deployment
      - name: Create deployment package
        shell: pwsh
        run: |
          Write-Host "Creating ZIP archive from publish folder..."

          # Remove existing ZIP if present
          if (Test-Path ${{ env.ZIP_FILE }}) {
            Remove-Item ${{ env.ZIP_FILE }} -Force
            Write-Host "Removed existing ZIP file"
          }

          # Create new ZIP archive
          Compress-Archive -Path ./publish/* -DestinationPath ${{ env.ZIP_FILE }} -Force

          # Verify ZIP was created and show size
          if (Test-Path ${{ env.ZIP_FILE }}) {
            $zipSize = (Get-Item ${{ env.ZIP_FILE }}).Length / 1MB
            Write-Host "âœ… ZIP created successfully: ${{ env.ZIP_FILE }}"
            Write-Host "ðŸ“¦ Package size: $($zipSize.ToString('F2')) MB"
          } else {
            Write-Error "âŒ Failed to create ZIP file"
            exit 1
          }

      # Step 9: Upload ZIP artifact for deployment job
      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: ${{ env.ZIP_FILE }}
          retention-days: 30
          if-no-files-found: error

      # Step 10: Add build summary
      - name: Build summary
        shell: pwsh
        run: |
          Write-Output "## ðŸŽ‰ Build Successful" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "**Project:** ${{ env.PROJECT_FILE }}" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "**Configuration:** Release" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "**Runtime:** linux-x64" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "**Package:** ${{ env.ZIP_FILE }}" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "âœ… Ready for deployment to ODC" >> $env:GITHUB_STEP_SUMMARY

  # ============================================================================
  # DEPLOY JOB - Upload library to OutSystems ODC
  # ============================================================================
  deploy:
    name: Deploy to ODC Development
    runs-on: windows-latest
    needs: build
    environment: development

    steps:
      # Step 1: Download the build artifact
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}

      # Step 2: Verify artifact was downloaded
      - name: Verify artifact
        shell: pwsh
        run: |
          Write-Host "Verifying downloaded artifact..."

          if (Test-Path ${{ env.ZIP_FILE }}) {
            $zipSize = (Get-Item ${{ env.ZIP_FILE }}).Length / 1MB
            Write-Host "âœ… Artifact found: ${{ env.ZIP_FILE }}"
            Write-Host "ðŸ“¦ Size: $($zipSize.ToString('F2')) MB"
          } else {
            Write-Error "âŒ Artifact not found: ${{ env.ZIP_FILE }}"
            exit 1
          }

      # ========================================================================
      # STEP 1: AUTHENTICATION - DIAGNOSTIC MODE
      # ========================================================================
      - name: "Step 1: Authenticate with ODC"
        id: auth
        shell: pwsh
        run: |
          $stepStart = Get-Date
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "STEP 1: AUTHENTICATION - DIAGNOSTIC MODE"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          try {
              # === ENVIRONMENT DIAGNOSTICS ===
              Write-Host "`nðŸ“Š ENVIRONMENT INFORMATION:"
              Write-Host "Runner OS: $env:RUNNER_OS"
              Write-Host "Runner Name: $env:RUNNER_NAME"
              Write-Host "PowerShell Version: $($PSVersionTable.PSVersion)"
              Write-Host "GitHub Actions: $env:GITHUB_ACTIONS"
              Write-Host ""

              # === NETWORK DIAGNOSTICS ===
              Write-Host "ðŸŒ NETWORK DIAGNOSTICS:"
              $portalDomain = ([System.Uri]"${{ secrets.ODC_PORTAL_URL }}").Host
              Write-Host "Portal Domain: $portalDomain"

              # Test DNS resolution
              try {
                  Write-Host "`nDNS Resolution Test:"
                  $dnsResult = Resolve-DnsName -Name $portalDomain -ErrorAction Stop
                  Write-Host "âœ… DNS Resolution successful"
                  Write-Host "IP Addresses: $($dnsResult.IPAddress -join ', ')"
              } catch {
                  Write-Host "âŒ DNS Resolution failed: $($_.Exception.Message)" -ForegroundColor Red
              }

              # Test basic connectivity
              try {
                  Write-Host "`nConnectivity Test:"
                  $testConnection = Test-NetConnection -ComputerName $portalDomain -Port 443 -InformationLevel Detailed -ErrorAction Stop
                  Write-Host "âœ… TCP Connection successful"
                  Write-Host "Ping Succeeded: $($testConnection.PingSucceeded)"
                  Write-Host "TCP Test Succeeded: $($testConnection.TcpTestSucceeded)"
                  Write-Host "Remote Address: $($testConnection.RemoteAddress)"
              } catch {
                  Write-Host "âŒ Connectivity test failed: $($_.Exception.Message)" -ForegroundColor Yellow
              }

              # Test HTTPS connectivity
              try {
                  Write-Host "`nHTTPS Test (Root URL):"
                  $rootTest = Invoke-WebRequest -Uri "${{ secrets.ODC_PORTAL_URL }}/" -Method Head -TimeoutSec 10 -UseBasicParsing -ErrorAction Stop
                  Write-Host "âœ… HTTPS connection successful"
                  Write-Host "Status Code: $($rootTest.StatusCode)"
              } catch {
                  Write-Host "âš ï¸  HTTPS root test: $($_.Exception.Message)" -ForegroundColor Yellow
                  Write-Host "Status Code: $($_.Exception.Response.StatusCode.value__)"
              }

              Write-Host ""
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

              # === CREDENTIALS CHECK ===
              Write-Host "`nðŸ” CREDENTIALS VERIFICATION:"
              Write-Host "Portal URL: ${{ secrets.ODC_PORTAL_URL }}"
              Write-Host "Client ID: ${{ secrets.ODC_CLIENT_ID }}"
              Write-Host "Client ID Length: $("${{ secrets.ODC_CLIENT_ID }}".Length) characters"
              Write-Host "Client Secret Length: $("${{ secrets.ODC_CLIENT_SECRET }}".Length) characters"
              Write-Host ""

              # === URL CONSTRUCTION DIAGNOSTICS ===
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Host "ðŸ”— URL CONSTRUCTION DIAGNOSTICS:"
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

              $baseUrl = "${{ secrets.ODC_PORTAL_URL }}"
              Write-Host "`nBase URL Analysis:"
              Write-Host "Raw value length: $($baseUrl.Length) characters"
              Write-Host "Starts with 'https://': $($baseUrl.StartsWith('https://'))"
              Write-Host "Starts with 'http://': $($baseUrl.StartsWith('http://'))"
              Write-Host "Ends with '/': $($baseUrl.EndsWith('/'))"
              Write-Host "Contains whitespace: $($baseUrl -match '\s')"

              # Show first and last few characters (safe to expose)
              if ($baseUrl.Length -gt 10) {
                  $firstChars = $baseUrl.Substring(0, [Math]::Min(20, $baseUrl.Length))
                  $lastChars = $baseUrl.Substring([Math]::Max(0, $baseUrl.Length - 15))
                  Write-Host "First 20 chars: '$firstChars...'"
                  Write-Host "Last 15 chars: '...$lastChars'"
              } else {
                  Write-Host "Value too short - possible issue!"
              }

              # Test URL construction
              $discoveryUrl = "$baseUrl/identity/.well-known/openid-configuration"
              $tokenUrl = "$baseUrl/auth/realms/29ecfa4f-ec23-4ebe-8d8c-6d556d1daba4/protocol/openid-connect/token"

              Write-Host "`nConstructed URLs:"
              Write-Host "Discovery URL length: $($discoveryUrl.Length)"
              Write-Host "Token URL length: $($tokenUrl.Length)"

              # Check for double slashes (common error)
              $hasDoubleSlash = $discoveryUrl -match '//'
              if ($hasDoubleSlash) {
                  Write-Host "âš ï¸  WARNING: Discovery URL contains '//' - check for trailing slash in base URL!" -ForegroundColor Yellow
              }

              # Validate URL format
              try {
                  $uri = [System.Uri]$baseUrl
                  Write-Host "`nURL Parse Test:"
                  Write-Host "âœ… Base URL is valid URI"
                  Write-Host "Scheme: $($uri.Scheme)"
                  Write-Host "Host: $($uri.Host)"
                  Write-Host "Port: $($uri.Port)"
                  Write-Host "Path: '$($uri.PathAndQuery)'"
              } catch {
                  Write-Host "âŒ Base URL is NOT a valid URI: $($_.Exception.Message)" -ForegroundColor Red
              }

              Write-Host ""

              # === OIDC DISCOVERY ATTEMPT ===
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Host "PHASE 1A: OIDC DISCOVERY"
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

              $tokenEndpoint = $null
              $discoveryUrl = "${{ secrets.ODC_PORTAL_URL }}/identity/.well-known/openid-configuration"

              try {
                  Write-Host "`nðŸ” Attempting OIDC Discovery..."
                  Write-Host "URL: $discoveryUrl"
                  Write-Host "Method: GET"
                  Write-Host "Expected Response: JSON with token_endpoint"
                  Write-Host ""

                  $discoveryResponse = Invoke-WebRequest -Uri $discoveryUrl -Method Get -UseBasicParsing -ErrorAction Stop

                  Write-Host "âœ… OIDC Discovery HTTP request succeeded!" -ForegroundColor Green
                  Write-Host "Status Code: $($discoveryResponse.StatusCode)"
                  Write-Host "Content Type: $($discoveryResponse.Headers.'Content-Type')"
                  Write-Host "Content Length: $($discoveryResponse.Content.Length) bytes"
                  Write-Host ""

                  $discovery = $discoveryResponse.Content | ConvertFrom-Json
                  $tokenEndpoint = $discovery.token_endpoint

                  Write-Host "âœ… OIDC Discovery parsed successfully!" -ForegroundColor Green
                  Write-Host "Issuer: $($discovery.issuer)"
                  Write-Host "Token Endpoint: $tokenEndpoint"
                  Write-Host "Supported Grants: $($discovery.grant_types_supported -join ', ')"

              } catch {
                  Write-Host "âŒ OIDC Discovery FAILED!" -ForegroundColor Red
                  Write-Host "Error Type: $($_.Exception.GetType().FullName)"
                  Write-Host "Error Message: $($_.Exception.Message)"

                  if ($_.Exception.Response) {
                      Write-Host "HTTP Status Code: $($_.Exception.Response.StatusCode.value__) - $($_.Exception.Response.StatusDescription)"
                      Write-Host "Response URL: $($_.Exception.Response.ResponseUri)"

                      try {
                          $reader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
                          $errorBody = $reader.ReadToEnd()
                          Write-Host "`nError Response Body:"
                          Write-Host $errorBody
                      } catch {
                          Write-Host "Could not read error response body"
                      }
                  }

                  Write-Host "`nâš ï¸  Falling back to hardcoded endpoint..." -ForegroundColor Yellow
                  $tokenEndpoint = "${{ secrets.ODC_PORTAL_URL }}/auth/realms/29ecfa4f-ec23-4ebe-8d8c-6d556d1daba4/protocol/openid-connect/token"
                  Write-Host "Fallback Token Endpoint: $tokenEndpoint"
              }

              if ([string]::IsNullOrEmpty($tokenEndpoint)) {
                  throw "FATAL: Could not determine token endpoint from discovery or fallback"
              }

              # === TOKEN REQUEST ATTEMPT ===
              Write-Host ""
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Host "PHASE 1B: TOKEN REQUEST"
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

              Write-Host "`nðŸ” Requesting OAuth2 Access Token..."
              Write-Host "Endpoint: $tokenEndpoint"
              Write-Host "Method: POST"
              Write-Host "Content-Type: application/x-www-form-urlencoded"
              Write-Host "Grant Type: client_credentials"
              Write-Host "Client ID: ${{ secrets.ODC_CLIENT_ID }}"
              Write-Host ""

              $body = @{
                  grant_type    = "client_credentials"
                  client_id     = "${{ secrets.ODC_CLIENT_ID }}"
                  client_secret = "${{ secrets.ODC_CLIENT_SECRET }}"
              }

              try {
                  $tokenResponse = Invoke-WebRequest -Uri $tokenEndpoint -Method Post -Body $body -ContentType "application/x-www-form-urlencoded" -UseBasicParsing -ErrorAction Stop

                  Write-Host "âœ… Token request HTTP succeeded!" -ForegroundColor Green
                  Write-Host "Status Code: $($tokenResponse.StatusCode)"
                  Write-Host "Content Type: $($tokenResponse.Headers.'Content-Type')"
                  Write-Host ""

                  $response = $tokenResponse.Content | ConvertFrom-Json
                  $accessToken = $response.access_token

                  if ([string]::IsNullOrEmpty($accessToken)) {
                      throw "FATAL: Access token is empty in response"
                  }

                  Write-Host "âœ… ACCESS TOKEN OBTAINED!" -ForegroundColor Green
                  Write-Host "Token Type: $($response.token_type)"
                  Write-Host "Token Length: $($accessToken.Length) characters"
                  Write-Host "Expires In: $($response.expires_in) seconds ($([Math]::Round($response.expires_in / 3600, 1)) hours)"

                  # Save and mask token
                  "ACCESS_TOKEN=$accessToken" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
                  Write-Host "::add-mask::$accessToken"

                  $stepDuration = (Get-Date) - $stepStart
                  Write-Host ""
                  Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                  Write-Host "âœ… STEP 1 COMPLETE - AUTHENTICATION SUCCESSFUL"
                  Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                  Write-Host "â±ï¸  Total time: $($stepDuration.TotalSeconds.ToString('F2'))s"
                  Write-Host ""

              } catch {
                  Write-Host "âŒ TOKEN REQUEST FAILED!" -ForegroundColor Red
                  Write-Host "Error Type: $($_.Exception.GetType().FullName)"
                  Write-Host "Error Message: $($_.Exception.Message)"

                  if ($_.Exception.Response) {
                      Write-Host "`nHTTP Response Details:"
                      Write-Host "Status Code: $($_.Exception.Response.StatusCode.value__) - $($_.Exception.Response.StatusDescription)"
                      Write-Host "Response URL: $($_.Exception.Response.ResponseUri)"

                      try {
                          $reader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
                          $errorBody = $reader.ReadToEnd()
                          Write-Host "`nError Response Body:"
                          Write-Host $errorBody

                          # Try to parse as JSON
                          try {
                              $errorJson = $errorBody | ConvertFrom-Json
                              if ($errorJson.error) {
                                  Write-Host "`nParsed OAuth Error:"
                                  Write-Host "Error: $($errorJson.error)"
                                  Write-Host "Description: $($errorJson.error_description)"
                              }
                          } catch {
                              # Not JSON, already displayed above
                          }
                      } catch {
                          Write-Host "Could not read error response body"
                      }
                  }

                  throw "Token request failed - see details above"
              }

          } catch {
              Write-Host ""
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Host "âŒ STEP 1 FAILED - AUTHENTICATION ERROR"
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Host "Error: $($_.Exception.Message)"
              Write-Host ""
              Write-Host "ðŸ” TROUBLESHOOTING CHECKLIST:"
              Write-Host "1. âœ“ Check DNS resolution above"
              Write-Host "2. âœ“ Check TCP connectivity above"
              Write-Host "3. âœ“ Check OIDC Discovery result above"
              Write-Host "4. âœ“ Check token request result above"
              Write-Host "5. Verify ODC_PORTAL_URL in GitHub Secrets"
              Write-Host "6. Verify ODC_CLIENT_ID and ODC_CLIENT_SECRET"
              Write-Host "7. Check API client permissions in ODC Portal"
              Write-Host "8. Consider using self-hosted runner if network blocked"
              Write-Host ""
              exit 1
          }

      # ========================================================================
      # STEP 2: Get Pre-signed Upload URL
      # ========================================================================
      - name: "Step 2: Get Upload URL"
        id: upload_url
        shell: pwsh
        env:
          ACCESS_TOKEN: ${{ steps.auth.outputs.ACCESS_TOKEN }}
          LIBRARY_KEY: ${{ secrets.ODC_LIBRARY_KEY }}
        run: |
          $stepStart = Get-Date
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "STEP 2: GET PRE-SIGNED UPLOAD URL (UPDATE EXISTING LIBRARY)"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          try {
            $apiUrl = "${{ secrets.ODC_PORTAL_URL }}/api/external-library-generation/v1/libraries/$env:LIBRARY_KEY/upload-url"
            Write-Host "ðŸ“¡ POST $apiUrl"
            Write-Host "Library Key: $env:LIBRARY_KEY"

            $headers = @{
              "Authorization" = "Bearer $env:ACCESS_TOKEN"
            }

            $response = Invoke-RestMethod -Uri $apiUrl -Method Post -Headers $headers

            $uploadUrl = $response.uploadUrl
            $downloadUrl = $response.downloadUrl

            if ([string]::IsNullOrEmpty($uploadUrl) -or [string]::IsNullOrEmpty($downloadUrl)) {
              throw "Missing uploadUrl or downloadUrl in response"
            }

            # Save URLs to outputs
            "UPLOAD_URL=$uploadUrl" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "DOWNLOAD_URL=$downloadUrl" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

            # Mask S3 URLs in logs
            Write-Host "::add-mask::$uploadUrl"
            Write-Host "::add-mask::$downloadUrl"

            $stepDuration = (Get-Date) - $stepStart
            Write-Host "âœ… Pre-signed URLs obtained"
            Write-Host "â±ï¸  Step 2 completed in $($stepDuration.TotalSeconds.ToString('F2'))s"
            Write-Host ""

          } catch {
            Write-Error "âŒ Step 2 failed: $($_.Exception.Message)"
            if ($_.Exception.Response) {
              $reader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
              Write-Host "Error details: $($reader.ReadToEnd())"
            }
            exit 1
          }

      # ========================================================================
      # STEP 3: Upload ZIP to S3
      # ========================================================================
      - name: "Step 3: Upload ZIP to S3"
        shell: pwsh
        env:
          UPLOAD_URL: ${{ steps.upload_url.outputs.UPLOAD_URL }}
        run: |
          $stepStart = Get-Date
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "STEP 3: UPLOAD ZIP TO S3"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          try {
            $zipPath = Resolve-Path ${{ env.ZIP_FILE }}
            $zipBytes = [System.IO.File]::ReadAllBytes($zipPath)
            $zipSizeMB = $zipBytes.Length / 1MB

            Write-Host "ðŸ“¦ File: ${{ env.ZIP_FILE }}"
            Write-Host "ðŸ“ Size: $($zipSizeMB.ToString('F2')) MB"
            Write-Host "ðŸš€ Uploading to S3..."

            $headers = @{
              "Content-Type" = "application/zip"
            }

            Invoke-RestMethod -Uri $env:UPLOAD_URL -Method Put -Headers $headers -Body $zipBytes | Out-Null

            $stepDuration = (Get-Date) - $stepStart
            Write-Host "âœ… ZIP uploaded successfully"
            Write-Host "â±ï¸  Step 3 completed in $($stepDuration.TotalSeconds.ToString('F2'))s"
            Write-Host ""

          } catch {
            Write-Error "âŒ Step 3 failed: $($_.Exception.Message)"
            exit 1
          }

      # ========================================================================
      # STEP 4: Register Upload and Create New Revision
      # ========================================================================
      - name: "Step 4: Register Upload and Create Revision"
        id: create_revision
        shell: pwsh
        env:
          ACCESS_TOKEN: ${{ steps.auth.outputs.ACCESS_TOKEN }}
          LIBRARY_KEY: ${{ secrets.ODC_LIBRARY_KEY }}
          DOWNLOAD_URL: ${{ steps.upload_url.outputs.DOWNLOAD_URL }}
        run: |
          $stepStart = Get-Date
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "STEP 4: REGISTER UPLOAD AND CREATE NEW REVISION"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          try {
            $apiUrl = "${{ secrets.ODC_PORTAL_URL }}/api/external-library-generation/v1/libraries/$env:LIBRARY_KEY/uploads"
            Write-Host "ðŸ“¡ POST $apiUrl"
            Write-Host "Library Key: $env:LIBRARY_KEY"

            $headers = @{
              "Authorization" = "Bearer $env:ACCESS_TOKEN"
              "Content-Type" = "application/json"
            }

            $body = @{
              downloadUrl = $env:DOWNLOAD_URL
            } | ConvertTo-Json

            Write-Host "`nRegistering upload and creating new revision..."
            Write-Host "Body: $body"

            $response = Invoke-RestMethod -Uri $apiUrl -Method Post -Headers $headers -Body $body

            Write-Host "`nðŸ“‹ Response:"
            Write-Host ($response | ConvertTo-Json -Depth 5)

            $libraryKey = $response.libraryKey
            $revisionNumber = $response.revisionNumber

            if ([string]::IsNullOrEmpty($libraryKey)) {
              throw "libraryKey not found in response"
            }

            if ([string]::IsNullOrEmpty($revisionNumber)) {
              throw "revisionNumber not found in response"
            }

            Write-Host "`nâœ… New revision created!"
            Write-Host "ðŸ”‘ Library Key: $libraryKey"
            Write-Host "ðŸ“ Revision Number: $revisionNumber"

            # Save for Step 5 (tagging)
            "LIBRARY_KEY=$libraryKey" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "REVISION_NUMBER=$revisionNumber" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

            $stepDuration = (Get-Date) - $stepStart
            Write-Host "â±ï¸  Step 4 completed in $($stepDuration.TotalSeconds.ToString('F2'))s"
            Write-Host ""

          } catch {
            Write-Error "âŒ Step 4 failed: $($_.Exception.Message)"
            if ($_.Exception.Response) {
              try {
                $reader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
                Write-Host "Error: $($reader.ReadToEnd())"
              } catch {}
            }
            exit 1
          }

      # ========================================================================
      # STEP 5: Create New Release Version
      # ========================================================================
      - name: "Step 5: Create New Release Version"
        id: release
        shell: pwsh
        env:
          ACCESS_TOKEN: ${{ steps.auth.outputs.ACCESS_TOKEN }}
          LIBRARY_KEY: ${{ steps.create_revision.outputs.LIBRARY_KEY }}
          REVISION_NUMBER: ${{ steps.create_revision.outputs.REVISION_NUMBER }}
        run: |
          $stepStart = Get-Date
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "STEP 5: CREATE NEW RELEASE VERSION"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          try {
              Write-Host "ðŸ”‘ Library Key: $env:LIBRARY_KEY"
              Write-Host "ðŸ“ Revision Number: $env:REVISION_NUMBER"

              # Query revisions to get existing tags for auto-increment
              $revisionsUrl = "${{ secrets.ODC_PORTAL_URL }}/api/asset-repository/v1/assets/$env:LIBRARY_KEY/revisions"
              Write-Host "`nðŸ“¡ GET $revisionsUrl"

              $headers = @{
                  "Authorization" = "Bearer $env:ACCESS_TOKEN"
              }

              $response = Invoke-RestMethod -Uri $revisionsUrl -Method Get -Headers $headers
              $revisions = $response.results

              Write-Host "Found $($revisions.Count) total revision(s)"

              # Use the revision number from Step 4
              $revisionNumber = $env:REVISION_NUMBER

              # Calculate next version number based on ALL existing tags
              $allTags = $revisions | Where-Object { $_.tag } | Select-Object -ExpandProperty tag | Sort-Object -Descending

              if ($allTags.Count -gt 0) {
                  $latestTag = $allTags[0]
                  Write-Host "Previous latest version: $latestTag"

                  # Auto-increment patch version
                  if ($latestTag -match '^(\d+)\.(\d+)\.(\d+)') {
                      $major = [int]$matches[1]
                      $minor = [int]$matches[2]
                      $patch = [int]$matches[3] + 1
                      $newTag = "$major.$minor.$patch"
                  } else {
                      $newTag = "0.1.${{ github.run_number }}"
                  }
              } else {
                  $newTag = "0.1.0"
              }

              Write-Host "`nðŸ“ Creating new release version: $newTag"
              Write-Host "This will create a new version entry for revision $revisionNumber"

              # Create new version by tagging the revision again
              $tagUrl = "${{ secrets.ODC_PORTAL_URL }}/api/asset-repository/v1/assets/$env:LIBRARY_KEY/revisions/$revisionNumber"
              Write-Host "`nðŸ“¡ PATCH $tagUrl"

              $headers["Content-Type"] = "application/json"

              $body = @{
                  tag = $newTag
                  releaseNotes = "Automated deployment from GitHub Actions`n`nRun: #${{ github.run_number }}`nCommit: ${{ github.sha }}`nBranch: ${{ github.ref_name }}`n`nTriggered by: ${{ github.event_name }}"
                  commitMessage = "Release $newTag via GitHub Actions"
              } | ConvertTo-Json

              Write-Host "Request body:"
              Write-Host $body
              Write-Host ""

              $tagResponse = Invoke-RestMethod -Uri $tagUrl -Method Patch -Headers $headers -Body $body

              Write-Host "âœ… Successfully created version $newTag!"
              Write-Host ""
              Write-Host "Response:"
              Write-Host ($tagResponse | ConvertTo-Json -Depth 3)

              # Save for summary
              "REVISION_NUMBER=$revisionNumber" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
              "VERSION_TAG=$newTag" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

              $stepDuration = (Get-Date) - $stepStart
              Write-Host "`nâ±ï¸  Step 6 completed in $($stepDuration.TotalSeconds.ToString('F2'))s"
              Write-Host ""

          } catch {
              Write-Error "âŒ Step 6 failed: $($_.Exception.Message)"
              if ($_.Exception.Response) {
                  Write-Host "`nHTTP Status: $($_.Exception.Response.StatusCode.value__)"
                  try {
                      $reader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
                      Write-Host "Error Response:"
                      Write-Host $($reader.ReadToEnd())
                  } catch {}
              }
              exit 1
          }

      # ========================================================================
      # STEP 6: Deployment Complete
      # ========================================================================
      - name: "Step 6: Deployment Complete"
        id: deploy
        shell: pwsh
        env:
          VERSION_TAG: ${{ steps.release.outputs.VERSION_TAG }}
          LIBRARY_NAME: ImageConverter
        run: |
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "ðŸŽ‰ DEPLOYMENT COMPLETE!"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host ""
          Write-Host "Library has been successfully:"
          Write-Host "âœ… Uploaded to ODC"
          Write-Host "âœ… Generated and processed"
          Write-Host "âœ… Tagged as release version $env:VERSION_TAG"
          Write-Host ""
          Write-Host "The library is now available in ODC Portal for:"
          Write-Host "- Manual deployment to stages"
          Write-Host "- Integration into applications"
          Write-Host "- Further configuration"
          Write-Host ""
          Write-Host "Next steps in ODC Portal:"
          Write-Host "1. Navigate to Libraries section"
          Write-Host "2. Find your library: $env:LIBRARY_NAME"
          Write-Host "3. Deploy the tagged revision to desired stage"
          Write-Host ""

      # ========================================================================
      # SUCCESS SUMMARY
      # ========================================================================
      - name: Deployment Summary
        if: success()
        shell: pwsh
        env:
          LIBRARY_NAME: ImageConverter
          LIBRARY_KEY: ${{ steps.create_revision.outputs.LIBRARY_KEY }}
          REVISION_NUMBER: ${{ steps.release.outputs.REVISION_NUMBER }}
          VERSION_TAG: ${{ steps.release.outputs.VERSION_TAG }}
        run: |
          Write-Output "## ðŸŽ‰ Deployment Successful" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "### Library Information" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Name:** $env:LIBRARY_NAME" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Library Key:** ``$env:LIBRARY_KEY``" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Revision:** $env:REVISION_NUMBER" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Version Tag:** $env:VERSION_TAG" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "### Deployment Details" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Environment:** Development" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Portal:** ${{ secrets.ODC_PORTAL_URL }}" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Deployed:** $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Run:** #${{ github.run_number }}" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "âœ… All 7 deployment steps completed successfully!" >> $env:GITHUB_STEP_SUMMARY

      # ========================================================================
      # FAILURE SUMMARY
      # ========================================================================
      - name: Deployment Failure Summary
        if: failure()
        shell: pwsh
        run: |
          Write-Output "## âŒ Deployment Failed" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "The deployment to ODC Development environment failed." >> $env:GITHUB_STEP_SUMMARY
          Write-Output "Please check the logs above for detailed error information." >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "### Common Issues" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 1:** Invalid credentials or OIDC Discovery failure" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 2:** API permissions or endpoint not available" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 3:** S3 upload failure or network issues" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 4:** Invalid ZIP package or generation request" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 5:** Generation timeout or compilation errors" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 6:** Release creation failure" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 7:** Deployment to stage failure" >> $env:GITHUB_STEP_SUMMARY
