name: Deploy to OutSystems ODC

# Trigger workflow on push to main branch or manual trigger
on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: false
        default: 'Development'
        type: string

# Define environment variables used across jobs
env:
  DOTNET_VERSION: '8.0.x'
  PROJECT_FILE: 'ImageConverterLibrary.csproj'
  ARTIFACT_NAME: 'ImageConverterLibrary'
  ZIP_FILE: 'ImageConverterLibrary.zip'

jobs:
  # ============================================================================
  # BUILD JOB - Compile and package the external logic library
  # ============================================================================
  build:
    name: Build External Logic Library
    runs-on: windows-latest

    steps:
      # Step 1: Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better context

      # Step 2: Setup .NET SDK
      - name: Setup .NET ${{ env.DOTNET_VERSION }}
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      # Step 3: Display .NET version for debugging
      - name: Display .NET version
        run: dotnet --version

      # Step 4: Inject Build Metadata and Code
      - name: Inject Build Metadata
        shell: pwsh
        run: |
          $buildId = "${{ github.run_number }}-${{ github.sha }}"
          $timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss UTC")
          $runNumber = "${{ github.run_number }}"

          Write-Host "Injecting build metadata:"
          Write-Host "  Build ID: $buildId"
          Write-Host "  Timestamp: $timestamp"
          Write-Host "  Run Number: $runNumber"

          # Create BuildInfo class with unique content
          $buildInfoPath = "BuildInfo.cs"
          @"
          using System;

          namespace ImageConverterLibrary
          {
              /// <summary>
              /// Auto-generated build information - DO NOT EDIT
              /// This class is regenerated on every build to force unique binary
              /// </summary>
              public static class BuildInfo
              {
                  public const string BuildId = "$buildId";
                  public const string BuildTimestamp = "$timestamp";
                  public const int BuildNumber = $runNumber;
                  public const string CommitSha = "${{ github.sha }}";

                  // Unique hash that changes every build
                  public const string BuildHash = "$buildId-$timestamp";
              }
          }
          "@ | Out-File -FilePath $buildInfoPath -Encoding UTF8

          Write-Host "âœ… BuildInfo.cs created with unique content"
          Write-Host "   This ensures ODC sees each build as different"

      # Step 5: Restore NuGet dependencies
      - name: Restore dependencies
        run: dotnet restore ${{ env.PROJECT_FILE }}

      # Step 6: Build the project in Release configuration with unique version
      - name: Build project
        shell: pwsh
        run: |
          Write-Host "Building with version 0.1.${{ github.run_number }}..."

          dotnet build ${{ env.PROJECT_FILE }} `
            --configuration Release `
            --no-restore `
            -p:Version=0.1.${{ github.run_number }} `
            -p:AssemblyVersion=0.1.${{ github.run_number }}.0 `
            -p:FileVersion=0.1.${{ github.run_number }}.0 `
            -p:Deterministic=false

          Write-Host "âœ… Build completed with unique version"

      # Step 7: Publish the project for linux-x64 runtime (ODC Lambda target)
      - name: Publish project
        shell: pwsh
        run: |
          Write-Host "Publishing library with version 0.1.${{ github.run_number }}..."

          dotnet publish ${{ env.PROJECT_FILE }} `
            --configuration Release `
            --runtime linux-x64 `
            --output ./publish `
            --no-build `
            -p:Version=0.1.${{ github.run_number }} `
            -p:AssemblyVersion=0.1.${{ github.run_number }}.0 `
            -p:FileVersion=0.1.${{ github.run_number }}.0 `
            -p:Deterministic=false

          Write-Host "âœ… Publish completed"
          Write-Host "Version: 0.1.${{ github.run_number }}"

      # Step 8: Create ZIP archive for ODC deployment
      - name: Create deployment package
        shell: pwsh
        run: |
          Write-Host "Creating ZIP archive from publish folder..."

          # Remove existing ZIP if present
          if (Test-Path ${{ env.ZIP_FILE }}) {
            Remove-Item ${{ env.ZIP_FILE }} -Force
            Write-Host "Removed existing ZIP file"
          }

          # Create new ZIP archive
          Compress-Archive -Path ./publish/* -DestinationPath ${{ env.ZIP_FILE }} -Force

          # Verify ZIP was created and show size
          if (Test-Path ${{ env.ZIP_FILE }}) {
            $zipSize = (Get-Item ${{ env.ZIP_FILE }}).Length / 1MB
            Write-Host "âœ… ZIP created successfully: ${{ env.ZIP_FILE }}"
            Write-Host "ğŸ“¦ Package size: $($zipSize.ToString('F2')) MB"
          } else {
            Write-Error "âŒ Failed to create ZIP file"
            exit 1
          }

      # Step 9: Upload ZIP artifact for deployment job
      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: ${{ env.ZIP_FILE }}
          retention-days: 30
          if-no-files-found: error

      # Step 10: Add build summary
      - name: Build summary
        shell: pwsh
        run: |
          Write-Output "## ğŸ‰ Build Successful" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "**Project:** ${{ env.PROJECT_FILE }}" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "**Configuration:** Release" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "**Runtime:** linux-x64" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "**Package:** ${{ env.ZIP_FILE }}" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "âœ… Ready for deployment to ODC" >> $env:GITHUB_STEP_SUMMARY

  # ============================================================================
  # DEPLOY JOB - Upload library to OutSystems ODC
  # ============================================================================
  deploy:
    name: Deploy to ODC Development
    runs-on: windows-latest
    needs: build
    environment: development

    steps:
      # Step 1: Download the build artifact
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}

      # Step 2: Verify artifact was downloaded
      - name: Verify artifact
        shell: pwsh
        run: |
          Write-Host "Verifying downloaded artifact..."

          if (Test-Path ${{ env.ZIP_FILE }}) {
            $zipSize = (Get-Item ${{ env.ZIP_FILE }}).Length / 1MB
            Write-Host "âœ… Artifact found: ${{ env.ZIP_FILE }}"
            Write-Host "ğŸ“¦ Size: $($zipSize.ToString('F2')) MB"
          } else {
            Write-Error "âŒ Artifact not found: ${{ env.ZIP_FILE }}"
            exit 1
          }

      # ========================================================================
      # STEP 1: AUTHENTICATION - DIAGNOSTIC MODE
      # ========================================================================
      - name: "Step 1: Authenticate with ODC"
        id: auth
        shell: pwsh
        run: |
          $stepStart = Get-Date
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "STEP 1: AUTHENTICATION - DIAGNOSTIC MODE"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          try {
              # === ENVIRONMENT DIAGNOSTICS ===
              Write-Host "`nğŸ“Š ENVIRONMENT INFORMATION:"
              Write-Host "Runner OS: $env:RUNNER_OS"
              Write-Host "Runner Name: $env:RUNNER_NAME"
              Write-Host "PowerShell Version: $($PSVersionTable.PSVersion)"
              Write-Host "GitHub Actions: $env:GITHUB_ACTIONS"
              Write-Host ""

              # === NETWORK DIAGNOSTICS ===
              Write-Host "ğŸŒ NETWORK DIAGNOSTICS:"
              $portalDomain = ([System.Uri]"${{ secrets.ODC_PORTAL_URL }}").Host
              Write-Host "Portal Domain: $portalDomain"

              # Test DNS resolution
              try {
                  Write-Host "`nDNS Resolution Test:"
                  $dnsResult = Resolve-DnsName -Name $portalDomain -ErrorAction Stop
                  Write-Host "âœ… DNS Resolution successful"
                  Write-Host "IP Addresses: $($dnsResult.IPAddress -join ', ')"
              } catch {
                  Write-Host "âŒ DNS Resolution failed: $($_.Exception.Message)" -ForegroundColor Red
              }

              # Test basic connectivity
              try {
                  Write-Host "`nConnectivity Test:"
                  $testConnection = Test-NetConnection -ComputerName $portalDomain -Port 443 -InformationLevel Detailed -ErrorAction Stop
                  Write-Host "âœ… TCP Connection successful"
                  Write-Host "Ping Succeeded: $($testConnection.PingSucceeded)"
                  Write-Host "TCP Test Succeeded: $($testConnection.TcpTestSucceeded)"
                  Write-Host "Remote Address: $($testConnection.RemoteAddress)"
              } catch {
                  Write-Host "âŒ Connectivity test failed: $($_.Exception.Message)" -ForegroundColor Yellow
              }

              # Test HTTPS connectivity
              try {
                  Write-Host "`nHTTPS Test (Root URL):"
                  $rootTest = Invoke-WebRequest -Uri "${{ secrets.ODC_PORTAL_URL }}/" -Method Head -TimeoutSec 10 -UseBasicParsing -ErrorAction Stop
                  Write-Host "âœ… HTTPS connection successful"
                  Write-Host "Status Code: $($rootTest.StatusCode)"
              } catch {
                  Write-Host "âš ï¸  HTTPS root test: $($_.Exception.Message)" -ForegroundColor Yellow
                  Write-Host "Status Code: $($_.Exception.Response.StatusCode.value__)"
              }

              Write-Host ""
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

              # === CREDENTIALS CHECK ===
              Write-Host "`nğŸ” CREDENTIALS VERIFICATION:"
              Write-Host "Portal URL: ${{ secrets.ODC_PORTAL_URL }}"
              Write-Host "Client ID: ${{ secrets.ODC_CLIENT_ID }}"
              Write-Host "Client ID Length: $("${{ secrets.ODC_CLIENT_ID }}".Length) characters"
              Write-Host "Client Secret Length: $("${{ secrets.ODC_CLIENT_SECRET }}".Length) characters"
              Write-Host ""

              # === URL CONSTRUCTION DIAGNOSTICS ===
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Host "ğŸ”— URL CONSTRUCTION DIAGNOSTICS:"
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

              $baseUrl = "${{ secrets.ODC_PORTAL_URL }}"
              Write-Host "`nBase URL Analysis:"
              Write-Host "Raw value length: $($baseUrl.Length) characters"
              Write-Host "Starts with 'https://': $($baseUrl.StartsWith('https://'))"
              Write-Host "Starts with 'http://': $($baseUrl.StartsWith('http://'))"
              Write-Host "Ends with '/': $($baseUrl.EndsWith('/'))"
              Write-Host "Contains whitespace: $($baseUrl -match '\s')"

              # Show first and last few characters (safe to expose)
              if ($baseUrl.Length -gt 10) {
                  $firstChars = $baseUrl.Substring(0, [Math]::Min(20, $baseUrl.Length))
                  $lastChars = $baseUrl.Substring([Math]::Max(0, $baseUrl.Length - 15))
                  Write-Host "First 20 chars: '$firstChars...'"
                  Write-Host "Last 15 chars: '...$lastChars'"
              } else {
                  Write-Host "Value too short - possible issue!"
              }

              # Test URL construction
              $discoveryUrl = "$baseUrl/identity/.well-known/openid-configuration"
              $tokenUrl = "$baseUrl/auth/realms/29ecfa4f-ec23-4ebe-8d8c-6d556d1daba4/protocol/openid-connect/token"

              Write-Host "`nConstructed URLs:"
              Write-Host "Discovery URL length: $($discoveryUrl.Length)"
              Write-Host "Token URL length: $($tokenUrl.Length)"

              # Check for double slashes (common error)
              $hasDoubleSlash = $discoveryUrl -match '//'
              if ($hasDoubleSlash) {
                  Write-Host "âš ï¸  WARNING: Discovery URL contains '//' - check for trailing slash in base URL!" -ForegroundColor Yellow
              }

              # Validate URL format
              try {
                  $uri = [System.Uri]$baseUrl
                  Write-Host "`nURL Parse Test:"
                  Write-Host "âœ… Base URL is valid URI"
                  Write-Host "Scheme: $($uri.Scheme)"
                  Write-Host "Host: $($uri.Host)"
                  Write-Host "Port: $($uri.Port)"
                  Write-Host "Path: '$($uri.PathAndQuery)'"
              } catch {
                  Write-Host "âŒ Base URL is NOT a valid URI: $($_.Exception.Message)" -ForegroundColor Red
              }

              Write-Host ""

              # === OIDC DISCOVERY ATTEMPT ===
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Host "PHASE 1A: OIDC DISCOVERY"
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

              $tokenEndpoint = $null
              $discoveryUrl = "${{ secrets.ODC_PORTAL_URL }}/identity/.well-known/openid-configuration"

              try {
                  Write-Host "`nğŸ” Attempting OIDC Discovery..."
                  Write-Host "URL: $discoveryUrl"
                  Write-Host "Method: GET"
                  Write-Host "Expected Response: JSON with token_endpoint"
                  Write-Host ""

                  $discoveryResponse = Invoke-WebRequest -Uri $discoveryUrl -Method Get -UseBasicParsing -ErrorAction Stop

                  Write-Host "âœ… OIDC Discovery HTTP request succeeded!" -ForegroundColor Green
                  Write-Host "Status Code: $($discoveryResponse.StatusCode)"
                  Write-Host "Content Type: $($discoveryResponse.Headers.'Content-Type')"
                  Write-Host "Content Length: $($discoveryResponse.Content.Length) bytes"
                  Write-Host ""

                  $discovery = $discoveryResponse.Content | ConvertFrom-Json
                  $tokenEndpoint = $discovery.token_endpoint

                  Write-Host "âœ… OIDC Discovery parsed successfully!" -ForegroundColor Green
                  Write-Host "Issuer: $($discovery.issuer)"
                  Write-Host "Token Endpoint: $tokenEndpoint"
                  Write-Host "Supported Grants: $($discovery.grant_types_supported -join ', ')"

              } catch {
                  Write-Host "âŒ OIDC Discovery FAILED!" -ForegroundColor Red
                  Write-Host "Error Type: $($_.Exception.GetType().FullName)"
                  Write-Host "Error Message: $($_.Exception.Message)"

                  if ($_.Exception.Response) {
                      Write-Host "HTTP Status Code: $($_.Exception.Response.StatusCode.value__) - $($_.Exception.Response.StatusDescription)"
                      Write-Host "Response URL: $($_.Exception.Response.ResponseUri)"

                      try {
                          $reader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
                          $errorBody = $reader.ReadToEnd()
                          Write-Host "`nError Response Body:"
                          Write-Host $errorBody
                      } catch {
                          Write-Host "Could not read error response body"
                      }
                  }

                  Write-Host "`nâš ï¸  Falling back to hardcoded endpoint..." -ForegroundColor Yellow
                  $tokenEndpoint = "${{ secrets.ODC_PORTAL_URL }}/auth/realms/29ecfa4f-ec23-4ebe-8d8c-6d556d1daba4/protocol/openid-connect/token"
                  Write-Host "Fallback Token Endpoint: $tokenEndpoint"
              }

              if ([string]::IsNullOrEmpty($tokenEndpoint)) {
                  throw "FATAL: Could not determine token endpoint from discovery or fallback"
              }

              # === TOKEN REQUEST ATTEMPT ===
              Write-Host ""
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Host "PHASE 1B: TOKEN REQUEST"
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

              Write-Host "`nğŸ” Requesting OAuth2 Access Token..."
              Write-Host "Endpoint: $tokenEndpoint"
              Write-Host "Method: POST"
              Write-Host "Content-Type: application/x-www-form-urlencoded"
              Write-Host "Grant Type: client_credentials"
              Write-Host "Client ID: ${{ secrets.ODC_CLIENT_ID }}"
              Write-Host ""

              $body = @{
                  grant_type    = "client_credentials"
                  client_id     = "${{ secrets.ODC_CLIENT_ID }}"
                  client_secret = "${{ secrets.ODC_CLIENT_SECRET }}"
              }

              try {
                  $tokenResponse = Invoke-WebRequest -Uri $tokenEndpoint -Method Post -Body $body -ContentType "application/x-www-form-urlencoded" -UseBasicParsing -ErrorAction Stop

                  Write-Host "âœ… Token request HTTP succeeded!" -ForegroundColor Green
                  Write-Host "Status Code: $($tokenResponse.StatusCode)"
                  Write-Host "Content Type: $($tokenResponse.Headers.'Content-Type')"
                  Write-Host ""

                  $response = $tokenResponse.Content | ConvertFrom-Json
                  $accessToken = $response.access_token

                  if ([string]::IsNullOrEmpty($accessToken)) {
                      throw "FATAL: Access token is empty in response"
                  }

                  Write-Host "âœ… ACCESS TOKEN OBTAINED!" -ForegroundColor Green
                  Write-Host "Token Type: $($response.token_type)"
                  Write-Host "Token Length: $($accessToken.Length) characters"
                  Write-Host "Expires In: $($response.expires_in) seconds ($([Math]::Round($response.expires_in / 3600, 1)) hours)"

                  # Save and mask token
                  "ACCESS_TOKEN=$accessToken" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
                  Write-Host "::add-mask::$accessToken"

                  $stepDuration = (Get-Date) - $stepStart
                  Write-Host ""
                  Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                  Write-Host "âœ… STEP 1 COMPLETE - AUTHENTICATION SUCCESSFUL"
                  Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                  Write-Host "â±ï¸  Total time: $($stepDuration.TotalSeconds.ToString('F2'))s"
                  Write-Host ""

              } catch {
                  Write-Host "âŒ TOKEN REQUEST FAILED!" -ForegroundColor Red
                  Write-Host "Error Type: $($_.Exception.GetType().FullName)"
                  Write-Host "Error Message: $($_.Exception.Message)"

                  if ($_.Exception.Response) {
                      Write-Host "`nHTTP Response Details:"
                      Write-Host "Status Code: $($_.Exception.Response.StatusCode.value__) - $($_.Exception.Response.StatusDescription)"
                      Write-Host "Response URL: $($_.Exception.Response.ResponseUri)"

                      try {
                          $reader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
                          $errorBody = $reader.ReadToEnd()
                          Write-Host "`nError Response Body:"
                          Write-Host $errorBody

                          # Try to parse as JSON
                          try {
                              $errorJson = $errorBody | ConvertFrom-Json
                              if ($errorJson.error) {
                                  Write-Host "`nParsed OAuth Error:"
                                  Write-Host "Error: $($errorJson.error)"
                                  Write-Host "Description: $($errorJson.error_description)"
                              }
                          } catch {
                              # Not JSON, already displayed above
                          }
                      } catch {
                          Write-Host "Could not read error response body"
                      }
                  }

                  throw "Token request failed - see details above"
              }

          } catch {
              Write-Host ""
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Host "âŒ STEP 1 FAILED - AUTHENTICATION ERROR"
              Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              Write-Host "Error: $($_.Exception.Message)"
              Write-Host ""
              Write-Host "ğŸ” TROUBLESHOOTING CHECKLIST:"
              Write-Host "1. âœ“ Check DNS resolution above"
              Write-Host "2. âœ“ Check TCP connectivity above"
              Write-Host "3. âœ“ Check OIDC Discovery result above"
              Write-Host "4. âœ“ Check token request result above"
              Write-Host "5. Verify ODC_PORTAL_URL in GitHub Secrets"
              Write-Host "6. Verify ODC_CLIENT_ID and ODC_CLIENT_SECRET"
              Write-Host "7. Check API client permissions in ODC Portal"
              Write-Host "8. Consider using self-hosted runner if network blocked"
              Write-Host ""
              exit 1
          }

      # ========================================================================
      # STEP 2: Get Pre-signed Upload URL
      # ========================================================================
      - name: "Step 2: Get Upload URL (Official API)"
        id: upload_url
        shell: pwsh
        env:
          ACCESS_TOKEN: ${{ steps.auth.outputs.ACCESS_TOKEN }}
          LIBRARY_KEY: ${{ secrets.ODC_LIBRARY_KEY }}
        run: |
          $stepStart = Get-Date
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "STEP 2: GET UPLOAD URL (OFFICIAL API STEP 1)"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          Write-Host "`nğŸ“¥ INPUTS:"
          Write-Host "  ACCESS_TOKEN: $(if($env:ACCESS_TOKEN) {'***SET***'} else {'NOT SET'})"
          Write-Host "  LIBRARY_KEY: $env:LIBRARY_KEY"
          Write-Host "  LIBRARY_KEY Length: $($env:LIBRARY_KEY.Length) chars"
          Write-Host "  LIBRARY_KEY Format: $(if($env:LIBRARY_KEY -match '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$') {'Valid GUID'} else {'Invalid GUID format'})"
          Write-Host ""

          try {
            Write-Host "âš ï¸  ATTEMPTING LIBRARY-SPECIFIC ENDPOINT (per Google docs)..."
            Write-Host "   This may return 404 if library doesn't exist or endpoint unavailable"
            Write-Host ""

            # Official API Step 1: POST /api/external-library-generation/v1/libraries/{libraryKey}/upload-url
            $apiUrl = "${{ secrets.ODC_PORTAL_URL }}/api/external-library-generation/v1/libraries/$env:LIBRARY_KEY/upload-url"
            Write-Host "ğŸ“¡ REQUEST (Attempt 1 - Library-Specific):"
            Write-Host "  Method: POST"
            Write-Host "  URL: $apiUrl"
            Write-Host "  Headers: Authorization: Bearer ***"
            Write-Host "  Body: (empty)"
            Write-Host ""

            $headers = @{
              "Authorization" = "Bearer $env:ACCESS_TOKEN"
            }

            try {
              $response = Invoke-RestMethod -Uri $apiUrl -Method Post -Headers $headers
              Write-Host "âœ… Library-specific endpoint worked!"
            } catch {
              if ($_.Exception.Response.StatusCode.value__ -eq 404) {
                Write-Host "âŒ 404 - Library-specific endpoint not found"
                Write-Host ""
                Write-Host "ğŸ”„ FALLBACK: Trying generic endpoint..."
                Write-Host ""

                # Fallback to generic endpoint
                $apiUrl = "${{ secrets.ODC_PORTAL_URL }}/api/external-libraries/v1/uploads"
                Write-Host "ğŸ“¡ REQUEST (Attempt 2 - Generic):"
                Write-Host "  Method: GET"
                Write-Host "  URL: $apiUrl"
                Write-Host ""

                $response = Invoke-RestMethod -Uri $apiUrl -Method Get -Headers $headers
                Write-Host "âœ… Generic endpoint worked!"
              } else {
                throw
              }
            }

            Write-Host "ğŸ“‹ RESPONSE:"
            Write-Host ($response | ConvertTo-Json -Depth 3)
            Write-Host ""

            $uploadUrl = $response.uploadUrl
            $downloadUrl = $response.downloadUrl

            Write-Host "ğŸ“¤ EXTRACTED VALUES:"
            Write-Host "  uploadUrl: $(if($uploadUrl) {'***SET***'} else {'MISSING'})"
            Write-Host "  downloadUrl: $(if($downloadUrl) {'***SET***'} else {'MISSING'})"
            Write-Host ""

            if ([string]::IsNullOrEmpty($uploadUrl) -or [string]::IsNullOrEmpty($downloadUrl)) {
              throw "Missing uploadUrl or downloadUrl in response"
            }

            # Save URLs to outputs
            "UPLOAD_URL=$uploadUrl" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "DOWNLOAD_URL=$downloadUrl" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

            # Mask S3 URLs in logs
            Write-Host "::add-mask::$uploadUrl"
            Write-Host "::add-mask::$downloadUrl"

            $stepDuration = (Get-Date) - $stepStart
            Write-Host "âœ… Pre-signed URLs obtained"
            Write-Host "â±ï¸  Step 2 completed in $($stepDuration.TotalSeconds.ToString('F2'))s"
            Write-Host ""

          } catch {
            Write-Error "âŒ Step 2 failed: $($_.Exception.Message)"
            if ($_.Exception.Response) {
              $reader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
              Write-Host "Error details: $($reader.ReadToEnd())"
            }
            exit 1
          }

      # ========================================================================
      # STEP 3: Upload ZIP to S3
      # ========================================================================
      - name: "Step 3: Upload ZIP to S3 (Official API Step 2)"
        shell: pwsh
        env:
          UPLOAD_URL: ${{ steps.upload_url.outputs.UPLOAD_URL }}
        run: |
          $stepStart = Get-Date
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "STEP 3: UPLOAD ZIP TO S3 (OFFICIAL API STEP 2)"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          Write-Host "`nğŸ“¥ INPUTS:"
          Write-Host "  UPLOAD_URL: $(if($env:UPLOAD_URL) {'***SET***'} else {'NOT SET'})"
          Write-Host "  ZIP_FILE: ${{ env.ZIP_FILE }}"
          Write-Host ""

          try {
            $zipPath = Resolve-Path ${{ env.ZIP_FILE }}
            $zipBytes = [System.IO.File]::ReadAllBytes($zipPath)
            $zipSizeMB = $zipBytes.Length / 1MB

            Write-Host "ğŸ“¡ REQUEST:"
            Write-Host "  Method: PUT"
            Write-Host "  URL: ***uploadUrl***"
            Write-Host "  Content-Type: application/zip"
            Write-Host "  Body Size: $($zipSizeMB.ToString('F2')) MB"
            Write-Host ""
            Write-Host "ğŸš€ Uploading to S3..."

            $headers = @{
              "Content-Type" = "application/zip"
            }

            Invoke-RestMethod -Uri $env:UPLOAD_URL -Method Put -Headers $headers -Body $zipBytes | Out-Null

            $stepDuration = (Get-Date) - $stepStart
            Write-Host "âœ… ZIP uploaded successfully"
            Write-Host "â±ï¸  Step 3 completed in $($stepDuration.TotalSeconds.ToString('F2'))s"
            Write-Host ""

          } catch {
            Write-Error "âŒ Step 3 failed: $($_.Exception.Message)"
            exit 1
          }

      # ========================================================================
      # STEP 4: Register Upload and Create New Revision
      # ========================================================================
      - name: "Step 4: Register Upload & Create Revision (Official API Step 3)"
        id: create_revision
        shell: pwsh
        env:
          ACCESS_TOKEN: ${{ steps.auth.outputs.ACCESS_TOKEN }}
          LIBRARY_KEY: ${{ secrets.ODC_LIBRARY_KEY }}
          DOWNLOAD_URL: ${{ steps.upload_url.outputs.DOWNLOAD_URL }}
        run: |
          $stepStart = Get-Date
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "STEP 4: REGISTER UPLOAD & CREATE NEW REVISION (OFFICIAL API STEP 3)"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          Write-Host "`nğŸ“¥ INPUTS:"
          Write-Host "  ACCESS_TOKEN: $(if($env:ACCESS_TOKEN) {'***SET***'} else {'NOT SET'})"
          Write-Host "  LIBRARY_KEY: $env:LIBRARY_KEY"
          Write-Host "  LIBRARY_KEY Length: $($env:LIBRARY_KEY.Length) chars"
          Write-Host "  LIBRARY_KEY Format: $(if($env:LIBRARY_KEY -match '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$') {'Valid GUID'} else {'Invalid GUID format'})"
          Write-Host "  DOWNLOAD_URL: $(if($env:DOWNLOAD_URL) {'***SET***'} else {'NOT SET'})"
          Write-Host ""

          try {
            $headers = @{
              "Authorization" = "Bearer $env:ACCESS_TOKEN"
              "Content-Type" = "application/json"
            }

            # ============================================================
            # PRE-FLIGHT CHECK: Verify library exists
            # ============================================================
            Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            Write-Host "PRE-FLIGHT: Verify library exists"
            Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

            $verifyUrl = "${{ secrets.ODC_PORTAL_URL }}/api/asset-repository/v1/assets/$env:LIBRARY_KEY"
            Write-Host "`nğŸ” Checking if library exists..."
            Write-Host "GET $verifyUrl"
            Write-Host ""

            try {
              $verifyResponse = Invoke-RestMethod -Uri $verifyUrl -Method Get -Headers $headers -ErrorAction Stop
              Write-Host "âœ… Library exists!"
              Write-Host "Library Name: $($verifyResponse.name)"
              Write-Host "Library Type: $($verifyResponse.type)"
              Write-Host "Current Revision: $($verifyResponse.currentRevisionNumber)"
              Write-Host ""
            } catch {
              $statusCode = $_.Exception.Response.StatusCode.value__
              Write-Host "âš ï¸  Library verification returned: $statusCode"

              if ($statusCode -eq 404) {
                Write-Host "âŒ Library does not exist at this key!"
                Write-Host "This may indicate:"
                Write-Host "  1. Wrong LIBRARY_KEY in secrets"
                Write-Host "  2. Library was deleted"
                Write-Host "  3. Insufficient API permissions"
              }

              Write-Host "`nContinuing anyway - the upload endpoint might still work..."
              Write-Host ""
            }

            # ============================================================
            # ATTEMPT 1: Library-specific endpoint (per Google docs)
            # ============================================================
            Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            Write-Host "ATTEMPT 1: Library-Specific Endpoint"
            Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

            $apiUrl = "${{ secrets.ODC_PORTAL_URL }}/api/external-library-generation/v1/libraries/$env:LIBRARY_KEY/uploads"

            $body = @{
              downloadUrl = $env:DOWNLOAD_URL
            } | ConvertTo-Json

            Write-Host "`nğŸ“¡ REQUEST:"
            Write-Host "  Method: POST"
            Write-Host "  URL: $apiUrl"
            Write-Host "  Headers: Authorization: Bearer ***"
            Write-Host "  Headers: Content-Type: application/json"
            Write-Host "  Body:"
            Write-Host $body
            Write-Host ""

            Write-Host "ğŸ”„ Attempting library-specific endpoint..."

            $response = $null
            $endpointUsed = $null

            try {
              $response = Invoke-RestMethod -Uri $apiUrl -Method Post -Headers $headers -Body $body -ErrorAction Stop
              $endpointUsed = "library-specific"
              Write-Host "âœ… Library-specific endpoint succeeded!"

            } catch {
              $statusCode = $_.Exception.Response.StatusCode.value__
              Write-Host "âŒ Library-specific endpoint failed: HTTP $statusCode"

              # Enhanced error logging
              Write-Host "`nğŸ” DETAILED ERROR INFORMATION:"
              Write-Host "  Exception Type: $($_.Exception.GetType().FullName)"
              Write-Host "  Error Message: $($_.Exception.Message)"
              Write-Host "  HTTP Status: $statusCode $($_.Exception.Response.StatusDescription)"

              if ($_.Exception.Response) {
                Write-Host "`n  Response Headers:"
                foreach ($header in $_.Exception.Response.Headers.AllKeys) {
                  Write-Host "    $header: $($_.Exception.Response.Headers[$header])"
                }

                try {
                  $reader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
                  $errorBody = $reader.ReadToEnd()
                  $reader.Close()

                  Write-Host "`n  Response Body:"
                  Write-Host "  $errorBody"

                  # Try to parse as JSON for structured error
                  try {
                    $errorJson = $errorBody | ConvertFrom-Json
                    Write-Host "`n  Parsed Error Details:"
                    Write-Host "  $($errorJson | ConvertTo-Json -Depth 3)"
                  } catch {
                    Write-Host "  (Response is not JSON)"
                  }
                } catch {
                  Write-Host "  Could not read response body"
                }
              }

              # ============================================================
              # ATTEMPT 2: Generic endpoint fallback
              # ============================================================
              if ($statusCode -eq 404) {
                Write-Host ""
                Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                Write-Host "ATTEMPT 2: Generic Endpoint Fallback"
                Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                Write-Host ""
                Write-Host "ğŸ”„ Trying generic generation endpoint..."

                # Try the generic endpoint without library key
                $genericUrl = "${{ secrets.ODC_PORTAL_URL }}/api/external-library-generation/v1/uploads"

                # Need to include library key in body for generic endpoint
                $genericBody = @{
                  downloadUrl = $env:DOWNLOAD_URL
                  libraryKey = $env:LIBRARY_KEY
                } | ConvertTo-Json

                Write-Host "ğŸ“¡ REQUEST (Generic):"
                Write-Host "  Method: POST"
                Write-Host "  URL: $genericUrl"
                Write-Host "  Body:"
                Write-Host $genericBody
                Write-Host ""

                try {
                  $response = Invoke-RestMethod -Uri $genericUrl -Method Post -Headers $headers -Body $genericBody -ErrorAction Stop
                  $endpointUsed = "generic"
                  Write-Host "âœ… Generic endpoint succeeded!"

                } catch {
                  Write-Host "âŒ Generic endpoint also failed: HTTP $($_.Exception.Response.StatusCode.value__)"

                  try {
                    $reader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
                    $errorBody = $reader.ReadToEnd()
                    Write-Host "Error: $errorBody"
                  } catch {}

                  throw "Both library-specific and generic endpoints failed"
                }
              } else {
                throw
              }
            }

            # ============================================================
            # PROCESS RESPONSE
            # ============================================================
            Write-Host ""
            Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            Write-Host "RESPONSE ANALYSIS"
            Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            Write-Host ""
            Write-Host "Endpoint used: $endpointUsed"
            Write-Host ""
            Write-Host "ğŸ“‹ FULL RESPONSE:"
            Write-Host ($response | ConvertTo-Json -Depth 5)
            Write-Host ""

            Write-Host "ğŸ“¤ RESPONSE STRUCTURE:"
            Write-Host "  Type: $($response.GetType().FullName)"
            Write-Host "  Properties: $($response.PSObject.Properties.Name -join ', ')"
            Write-Host ""

            # Extract all possible fields
            $revisionNumber = $response.revisionNumber
            $libraryKey = $response.libraryKey
            $assetKey = $response.assetKey
            $operationKey = $response.operationKey

            Write-Host "ğŸ“¤ EXTRACTED FIELDS:"
            Write-Host "  revisionNumber: $(if($revisionNumber) {$revisionNumber} else {'<not found>'})"
            Write-Host "  libraryKey: $(if($libraryKey) {$libraryKey} else {'<not found>'})"
            Write-Host "  assetKey: $(if($assetKey) {$assetKey} else {'<not found>'})"
            Write-Host "  operationKey: $(if($operationKey) {$operationKey} else {'<not found>'})"
            Write-Host ""

            # Check if we got a revision number
            if ([string]::IsNullOrEmpty($revisionNumber)) {
              Write-Host "âŒ revisionNumber not found in response!"

              if ($operationKey) {
                Write-Host "âš ï¸  API returned async operation (operationKey: $operationKey)"
                Write-Host "This is UNEXPECTED per official docs - should be synchronous"
                throw "API returned async operation instead of revision - polling not implemented"
              } else {
                Write-Host "âŒ No revisionNumber AND no operationKey!"
                Write-Host "Cannot determine revision - API response is invalid"
                throw "revisionNumber not found in response and no operationKey for polling"
              }
            }

            Write-Host "âœ… New revision created: $revisionNumber"
            Write-Host ""

            # Use assetKey if present, otherwise fall back to libraryKey from response, then input
            $finalAssetKey = if ($assetKey) {
              Write-Host "Using assetKey from response: $assetKey"
              $assetKey
            } elseif ($libraryKey) {
              Write-Host "Using libraryKey from response: $libraryKey"
              $libraryKey
            } else {
              Write-Host "Using LIBRARY_KEY from input: $env:LIBRARY_KEY"
              $env:LIBRARY_KEY
            }

            # Save for Step 5
            "LIBRARY_KEY=$finalAssetKey" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "REVISION_NUMBER=$revisionNumber" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

            $stepDuration = (Get-Date) - $stepStart
            Write-Host ""
            Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            Write-Host "âœ… STEP 4 COMPLETE"
            Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            Write-Host "Revision: $revisionNumber"
            Write-Host "â±ï¸  Total time: $($stepDuration.TotalSeconds.ToString('F2'))s"
            Write-Host ""

          } catch {
            Write-Host ""
            Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            Write-Host "âŒ STEP 4 FAILED"
            Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            Write-Error "Error: $($_.Exception.Message)"
            Write-Host ""
            Write-Host "ğŸ” TROUBLESHOOTING:"
            Write-Host "1. Verify LIBRARY_KEY matches an existing library in ODC"
            Write-Host "2. Check API client has 'Generate External Logic' permission"
            Write-Host "3. Verify the library hasn't been deleted"
            Write-Host "4. Check if ODC version supports these API endpoints"
            Write-Host "5. Try creating a new library via ODC Portal first"
            Write-Host ""
            exit 1
          }

      # ========================================================================
      # STEP 5: Create New Release Version
      # ========================================================================
      - name: "Step 5: Create New Release Version"
        id: release
        shell: pwsh
        env:
          ACCESS_TOKEN: ${{ steps.auth.outputs.ACCESS_TOKEN }}
          LIBRARY_KEY: ${{ steps.create_revision.outputs.LIBRARY_KEY }}
          REVISION_NUMBER: ${{ steps.create_revision.outputs.REVISION_NUMBER }}
        run: |
          $stepStart = Get-Date
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "STEP 5: CREATE NEW RELEASE VERSION"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          try {
              Write-Host "ğŸ”‘ Library Key: $env:LIBRARY_KEY"
              Write-Host "ğŸ“ Revision Number: $env:REVISION_NUMBER"

              # Query revisions to get existing tags for auto-increment
              $revisionsUrl = "${{ secrets.ODC_PORTAL_URL }}/api/asset-repository/v1/assets/$env:LIBRARY_KEY/revisions"
              Write-Host "`nğŸ“¡ GET $revisionsUrl"

              $headers = @{
                  "Authorization" = "Bearer $env:ACCESS_TOKEN"
              }

              $response = Invoke-RestMethod -Uri $revisionsUrl -Method Get -Headers $headers
              $revisions = $response.results

              Write-Host "Found $($revisions.Count) total revision(s)"

              # Use the revision number from Step 4
              $revisionNumber = $env:REVISION_NUMBER

              # Calculate next version number based on ALL existing tags
              $allTags = $revisions | Where-Object { $_.tag } | Select-Object -ExpandProperty tag | Sort-Object -Descending

              if ($allTags.Count -gt 0) {
                  $latestTag = $allTags[0]
                  Write-Host "Previous latest version: $latestTag"

                  # Auto-increment patch version
                  if ($latestTag -match '^(\d+)\.(\d+)\.(\d+)') {
                      $major = [int]$matches[1]
                      $minor = [int]$matches[2]
                      $patch = [int]$matches[3] + 1
                      $newTag = "$major.$minor.$patch"
                  } else {
                      $newTag = "0.1.${{ github.run_number }}"
                  }
              } else {
                  $newTag = "0.1.0"
              }

              Write-Host "`nğŸ“ Creating new release version: $newTag"
              Write-Host "This will create a new version entry for revision $revisionNumber"

              # Create new version by tagging the revision again
              $tagUrl = "${{ secrets.ODC_PORTAL_URL }}/api/asset-repository/v1/assets/$env:LIBRARY_KEY/revisions/$revisionNumber"
              Write-Host "`nğŸ“¡ PATCH $tagUrl"

              $headers["Content-Type"] = "application/json"

              $body = @{
                  tag = $newTag
                  releaseNotes = "Automated deployment from GitHub Actions`n`nRun: #${{ github.run_number }}`nCommit: ${{ github.sha }}`nBranch: ${{ github.ref_name }}`n`nTriggered by: ${{ github.event_name }}"
                  commitMessage = "Release $newTag via GitHub Actions"
              } | ConvertTo-Json

              Write-Host "Request body:"
              Write-Host $body
              Write-Host ""

              $tagResponse = Invoke-RestMethod -Uri $tagUrl -Method Patch -Headers $headers -Body $body

              Write-Host "âœ… Successfully created version $newTag!"
              Write-Host ""
              Write-Host "Response:"
              Write-Host ($tagResponse | ConvertTo-Json -Depth 3)

              # Save for summary
              "REVISION_NUMBER=$revisionNumber" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
              "VERSION_TAG=$newTag" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

              $stepDuration = (Get-Date) - $stepStart
              Write-Host "`nâ±ï¸  Step 6 completed in $($stepDuration.TotalSeconds.ToString('F2'))s"
              Write-Host ""

          } catch {
              Write-Error "âŒ Step 6 failed: $($_.Exception.Message)"
              if ($_.Exception.Response) {
                  Write-Host "`nHTTP Status: $($_.Exception.Response.StatusCode.value__)"
                  try {
                      $reader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
                      Write-Host "Error Response:"
                      Write-Host $($reader.ReadToEnd())
                  } catch {}
              }
              exit 1
          }

      # ========================================================================
      # STEP 6: Deployment Complete
      # ========================================================================
      - name: "Step 6: Deployment Complete"
        id: deploy
        shell: pwsh
        env:
          VERSION_TAG: ${{ steps.release.outputs.VERSION_TAG }}
          LIBRARY_NAME: ImageConverter
        run: |
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "ğŸ‰ DEPLOYMENT COMPLETE!"
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host ""
          Write-Host "Library has been successfully:"
          Write-Host "âœ… Uploaded to ODC"
          Write-Host "âœ… Generated and processed"
          Write-Host "âœ… Tagged as release version $env:VERSION_TAG"
          Write-Host ""
          Write-Host "The library is now available in ODC Portal for:"
          Write-Host "- Manual deployment to stages"
          Write-Host "- Integration into applications"
          Write-Host "- Further configuration"
          Write-Host ""
          Write-Host "Next steps in ODC Portal:"
          Write-Host "1. Navigate to Libraries section"
          Write-Host "2. Find your library: $env:LIBRARY_NAME"
          Write-Host "3. Deploy the tagged revision to desired stage"
          Write-Host ""

      # ========================================================================
      # SUCCESS SUMMARY
      # ========================================================================
      - name: Deployment Summary
        if: success()
        shell: pwsh
        env:
          LIBRARY_NAME: ImageConverter
          LIBRARY_KEY: ${{ steps.create_revision.outputs.LIBRARY_KEY }}
          REVISION_NUMBER: ${{ steps.release.outputs.REVISION_NUMBER }}
          VERSION_TAG: ${{ steps.release.outputs.VERSION_TAG }}
        run: |
          Write-Output "## ğŸ‰ Deployment Successful" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "### Library Information" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Name:** $env:LIBRARY_NAME" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Library Key:** ``$env:LIBRARY_KEY``" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Revision:** $env:REVISION_NUMBER" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Version Tag:** $env:VERSION_TAG" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "### Deployment Details" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Environment:** Development" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Portal:** ${{ secrets.ODC_PORTAL_URL }}" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Deployed:** $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Run:** #${{ github.run_number }}" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "âœ… All 7 deployment steps completed successfully!" >> $env:GITHUB_STEP_SUMMARY

      # ========================================================================
      # FAILURE SUMMARY
      # ========================================================================
      - name: Deployment Failure Summary
        if: failure()
        shell: pwsh
        run: |
          Write-Output "## âŒ Deployment Failed" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "The deployment to ODC Development environment failed." >> $env:GITHUB_STEP_SUMMARY
          Write-Output "Please check the logs above for detailed error information." >> $env:GITHUB_STEP_SUMMARY
          Write-Output "" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "### Common Issues" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 1:** Invalid credentials or OIDC Discovery failure" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 2:** API permissions or endpoint not available" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 3:** S3 upload failure or network issues" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 4:** Invalid ZIP package or generation request" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 5:** Generation timeout or compilation errors" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 6:** Release creation failure" >> $env:GITHUB_STEP_SUMMARY
          Write-Output "- **Step 7:** Deployment to stage failure" >> $env:GITHUB_STEP_SUMMARY
